// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int __ctype_get_mb_cur_max() {
    return ___ctype_get_mb_cur_max();
  }

  late final ___ctype_get_mb_cur_maxPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          '__ctype_get_mb_cur_max');
  late final ___ctype_get_mb_cur_max =
      ___ctype_get_mb_cur_maxPtr.asFunction<int Function()>();

  double atof(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atof(
      __nptr,
    );
  }

  late final _atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'atof');
  late final _atof =
      _atofPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int atoi(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atoi(
      __nptr,
    );
  }

  late final _atoiPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'atoi');
  late final _atoi = _atoiPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atol(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atol(
      __nptr,
    );
  }

  late final _atolPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'atol');
  late final _atol = _atolPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atoll(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atoll(
      __nptr,
    );
  }

  late final _atollPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Pointer<ffi.Char>)>>(
          'atoll');
  late final _atoll =
      _atollPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double strtod(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
  ) {
    return _strtod(
      __nptr,
      __endptr,
    );
  }

  late final _strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtod');
  late final _strtod = _strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  double strtof(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
  ) {
    return _strtof(
      __nptr,
      __endptr,
    );
  }

  late final _strtofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtof');
  late final _strtof = _strtofPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtol(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtol(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtol');
  late final _strtol = _strtolPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoul(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoul(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoulPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoul');
  late final _strtoul = _strtoulPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoq(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoq(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoqPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoq');
  late final _strtoq = _strtoqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtouq(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtouq(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtouqPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtouq');
  late final _strtouq = _strtouqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoll(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoll(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtollPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoll');
  late final _strtoll = _strtollPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoull(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoull(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoullPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoull');
  late final _strtoull = _strtoullPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  ffi.Pointer<ffi.Char> l64a(
    int __n,
  ) {
    return _l64a(
      __n,
    );
  }

  late final _l64aPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Long)>>(
          'l64a');
  late final _l64a = _l64aPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int a64l(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _a64l(
      __s,
    );
  }

  late final _a64lPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'a64l');
  late final _a64l = _a64lPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int select(
    int __nfds,
    ffi.Pointer<fd_set> __readfds,
    ffi.Pointer<fd_set> __writefds,
    ffi.Pointer<fd_set> __exceptfds,
    ffi.Pointer<timeval> __timeout,
  ) {
    return _select(
      __nfds,
      __readfds,
      __writefds,
      __exceptfds,
      __timeout,
    );
  }

  late final _selectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<fd_set>, ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>, ffi.Pointer<timeval>)>>('select');
  late final _select = _selectPtr.asFunction<
      int Function(int, ffi.Pointer<fd_set>, ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>, ffi.Pointer<timeval>)>();

  int pselect(
    int __nfds,
    ffi.Pointer<fd_set> __readfds,
    ffi.Pointer<fd_set> __writefds,
    ffi.Pointer<fd_set> __exceptfds,
    ffi.Pointer<timespec> __timeout,
    ffi.Pointer<__sigset_t> __sigmask,
  ) {
    return _pselect(
      __nfds,
      __readfds,
      __writefds,
      __exceptfds,
      __timeout,
      __sigmask,
    );
  }

  late final _pselectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>,
              ffi.Pointer<timespec>,
              ffi.Pointer<__sigset_t>)>>('pselect');
  late final _pselect = _pselectPtr.asFunction<
      int Function(
          int,
          ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>,
          ffi.Pointer<timespec>,
          ffi.Pointer<__sigset_t>)>();

  int random() {
    return _random();
  }

  late final _randomPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('random');
  late final _random = _randomPtr.asFunction<int Function()>();

  void srandom(
    int __seed,
  ) {
    return _srandom(
      __seed,
    );
  }

  late final _srandomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'srandom');
  late final _srandom = _srandomPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> initstate(
    int __seed,
    ffi.Pointer<ffi.Char> __statebuf,
    int __statelen,
  ) {
    return _initstate(
      __seed,
      __statebuf,
      __statelen,
    );
  }

  late final _initstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size)>>('initstate');
  late final _initstate = _initstatePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> setstate(
    ffi.Pointer<ffi.Char> __statebuf,
  ) {
    return _setstate(
      __statebuf,
    );
  }

  late final _setstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('setstate');
  late final _setstate = _setstatePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int random_r(
    ffi.Pointer<random_data> __buf,
    ffi.Pointer<ffi.Int32> __result,
  ) {
    return _random_r(
      __buf,
      __result,
    );
  }

  late final _random_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<random_data>, ffi.Pointer<ffi.Int32>)>>('random_r');
  late final _random_r = _random_rPtr.asFunction<
      int Function(ffi.Pointer<random_data>, ffi.Pointer<ffi.Int32>)>();

  int srandom_r(
    int __seed,
    ffi.Pointer<random_data> __buf,
  ) {
    return _srandom_r(
      __seed,
      __buf,
    );
  }

  late final _srandom_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedInt, ffi.Pointer<random_data>)>>('srandom_r');
  late final _srandom_r =
      _srandom_rPtr.asFunction<int Function(int, ffi.Pointer<random_data>)>();

  int initstate_r(
    int __seed,
    ffi.Pointer<ffi.Char> __statebuf,
    int __statelen,
    ffi.Pointer<random_data> __buf,
  ) {
    return _initstate_r(
      __seed,
      __statebuf,
      __statelen,
      __buf,
    );
  }

  late final _initstate_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<random_data>)>>('initstate_r');
  late final _initstate_r = _initstate_rPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<random_data>)>();

  int setstate_r(
    ffi.Pointer<ffi.Char> __statebuf,
    ffi.Pointer<random_data> __buf,
  ) {
    return _setstate_r(
      __statebuf,
      __buf,
    );
  }

  late final _setstate_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<random_data>)>>('setstate_r');
  late final _setstate_r = _setstate_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<random_data>)>();

  int rand() {
    return _rand();
  }

  late final _randPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('rand');
  late final _rand = _randPtr.asFunction<int Function()>();

  void srand(
    int __seed,
  ) {
    return _srand(
      __seed,
    );
  }

  late final _srandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>('srand');
  late final _srand = _srandPtr.asFunction<void Function(int)>();

  int rand_r(
    ffi.Pointer<ffi.UnsignedInt> __seed,
  ) {
    return _rand_r(
      __seed,
    );
  }

  late final _rand_rPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>)>>(
      'rand_r');
  late final _rand_r =
      _rand_rPtr.asFunction<int Function(ffi.Pointer<ffi.UnsignedInt>)>();

  double drand48() {
    return _drand48();
  }

  late final _drand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('drand48');
  late final _drand48 = _drand48Ptr.asFunction<double Function()>();

  double erand48(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
  ) {
    return _erand48(
      __xsubi,
    );
  }

  late final _erand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.UnsignedShort>)>>('erand48');
  late final _erand48 =
      _erand48Ptr.asFunction<double Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int lrand48() {
    return _lrand48();
  }

  late final _lrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('lrand48');
  late final _lrand48 = _lrand48Ptr.asFunction<int Function()>();

  int nrand48(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
  ) {
    return _nrand48(
      __xsubi,
    );
  }

  late final _nrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('nrand48');
  late final _nrand48 =
      _nrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int mrand48() {
    return _mrand48();
  }

  late final _mrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('mrand48');
  late final _mrand48 = _mrand48Ptr.asFunction<int Function()>();

  int jrand48(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
  ) {
    return _jrand48(
      __xsubi,
    );
  }

  late final _jrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('jrand48');
  late final _jrand48 =
      _jrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  void srand48(
    int __seedval,
  ) {
    return _srand48(
      __seedval,
    );
  }

  late final _srand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Long)>>('srand48');
  late final _srand48 = _srand48Ptr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.UnsignedShort> seed48(
    ffi.Pointer<ffi.UnsignedShort> __seed16v,
  ) {
    return _seed48(
      __seed16v,
    );
  }

  late final _seed48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
              ffi.Pointer<ffi.UnsignedShort>)>>('seed48');
  late final _seed48 = _seed48Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(
          ffi.Pointer<ffi.UnsignedShort>)>();

  void lcong48(
    ffi.Pointer<ffi.UnsignedShort> __param,
  ) {
    return _lcong48(
      __param,
    );
  }

  late final _lcong48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>)>>('lcong48');
  late final _lcong48 =
      _lcong48Ptr.asFunction<void Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int drand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Double> __result,
  ) {
    return _drand48_r(
      __buffer,
      __result,
    );
  }

  late final _drand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<drand48_data>,
              ffi.Pointer<ffi.Double>)>>('drand48_r');
  late final _drand48_r = _drand48_rPtr.asFunction<
      int Function(ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Double>)>();

  int erand48_r(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Double> __result,
  ) {
    return _erand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _erand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>,
              ffi.Pointer<ffi.Double>)>>('erand48_r');
  late final _erand48_r = _erand48_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>,
          ffi.Pointer<ffi.Double>)>();

  int lrand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _lrand48_r(
      __buffer,
      __result,
    );
  }

  late final _lrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('lrand48_r');
  late final _lrand48_r = _lrand48_rPtr.asFunction<
      int Function(ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>();

  int nrand48_r(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _nrand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _nrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('nrand48_r');
  late final _nrand48_r = _nrand48_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>,
          ffi.Pointer<ffi.Long>)>();

  int mrand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _mrand48_r(
      __buffer,
      __result,
    );
  }

  late final _mrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('mrand48_r');
  late final _mrand48_r = _mrand48_rPtr.asFunction<
      int Function(ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>();

  int jrand48_r(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _jrand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _jrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('jrand48_r');
  late final _jrand48_r = _jrand48_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>,
          ffi.Pointer<ffi.Long>)>();

  int srand48_r(
    int __seedval,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _srand48_r(
      __seedval,
      __buffer,
    );
  }

  late final _srand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Long, ffi.Pointer<drand48_data>)>>('srand48_r');
  late final _srand48_r =
      _srand48_rPtr.asFunction<int Function(int, ffi.Pointer<drand48_data>)>();

  int seed48_r(
    ffi.Pointer<ffi.UnsignedShort> __seed16v,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _seed48_r(
      __seed16v,
      __buffer,
    );
  }

  late final _seed48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>)>>('seed48_r');
  late final _seed48_r = _seed48_rPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>)>();

  int lcong48_r(
    ffi.Pointer<ffi.UnsignedShort> __param,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _lcong48_r(
      __param,
      __buffer,
    );
  }

  late final _lcong48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>)>>('lcong48_r');
  late final _lcong48_r = _lcong48_rPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>)>();

  int arc4random() {
    return _arc4random();
  }

  late final _arc4randomPtr =
      _lookup<ffi.NativeFunction<__uint32_t Function()>>('arc4random');
  late final _arc4random = _arc4randomPtr.asFunction<int Function()>();

  void arc4random_buf(
    ffi.Pointer<ffi.Void> __buf,
    int __size,
  ) {
    return _arc4random_buf(
      __buf,
      __size,
    );
  }

  late final _arc4random_bufPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>>(
      'arc4random_buf');
  late final _arc4random_buf = _arc4random_bufPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  int arc4random_uniform(
    int __upper_bound,
  ) {
    return _arc4random_uniform(
      __upper_bound,
    );
  }

  late final _arc4random_uniformPtr =
      _lookup<ffi.NativeFunction<__uint32_t Function(__uint32_t)>>(
          'arc4random_uniform');
  late final _arc4random_uniform =
      _arc4random_uniformPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Void> malloc(
    int __size,
  ) {
    return _malloc(
      __size,
    );
  }

  late final _mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'malloc');
  late final _malloc =
      _mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> calloc(
    int __nmemb,
    int __size,
  ) {
    return _calloc(
      __nmemb,
      __size,
    );
  }

  late final _callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('calloc');
  late final _calloc =
      _callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> realloc(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _realloc(
      __ptr,
      __size,
    );
  }

  late final _reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('realloc');
  late final _realloc = _reallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void free(
    ffi.Pointer<ffi.Void> __ptr,
  ) {
    return _free(
      __ptr,
    );
  }

  late final _freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'free');
  late final _free =
      _freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> reallocarray(
    ffi.Pointer<ffi.Void> __ptr,
    int __nmemb,
    int __size,
  ) {
    return _reallocarray(
      __ptr,
      __nmemb,
      __size,
    );
  }

  late final _reallocarrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size)>>('reallocarray');
  late final _reallocarray = _reallocarrayPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> alloca(
    int __size,
  ) {
    return _alloca(
      __size,
    );
  }

  late final _allocaPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'alloca');
  late final _alloca =
      _allocaPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> valloc(
    int __size,
  ) {
    return _valloc(
      __size,
    );
  }

  late final _vallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'valloc');
  late final _valloc =
      _vallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  int posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
    int __alignment,
    int __size,
  ) {
    return _posix_memalign(
      __memptr,
      __alignment,
      __size,
    );
  }

  late final _posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size)>>('posix_memalign');
  late final _posix_memalign = _posix_memalignPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int)>();

  ffi.Pointer<ffi.Void> aligned_alloc(
    int __alignment,
    int __size,
  ) {
    return _aligned_alloc(
      __alignment,
      __size,
    );
  }

  late final _aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('aligned_alloc');
  late final _aligned_alloc =
      _aligned_allocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  void abort() {
    return _abort();
  }

  late final _abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('abort');
  late final _abort = _abortPtr.asFunction<void Function()>();

  int atexit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> __func,
  ) {
    return _atexit(
      __func,
    );
  }

  late final _atexitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>('atexit');
  late final _atexit = _atexitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  int at_quick_exit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> __func,
  ) {
    return _at_quick_exit(
      __func,
    );
  }

  late final _at_quick_exitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>(
      'at_quick_exit');
  late final _at_quick_exit = _at_quick_exitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  int on_exit(
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Int __status, ffi.Pointer<ffi.Void> __arg)>>
        __func,
    ffi.Pointer<ffi.Void> __arg,
  ) {
    return _on_exit(
      __func,
      __arg,
    );
  }

  late final _on_exitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Int __status, ffi.Pointer<ffi.Void> __arg)>>,
              ffi.Pointer<ffi.Void>)>>('on_exit');
  late final _on_exit = _on_exitPtr.asFunction<
      int Function(
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Int __status, ffi.Pointer<ffi.Void> __arg)>>,
          ffi.Pointer<ffi.Void>)>();

  void exit(
    int __status,
  ) {
    return _exit(
      __status,
    );
  }

  late final _exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('exit');
  late final _exit = _exitPtr.asFunction<void Function(int)>();

  void quick_exit(
    int __status,
  ) {
    return _quick_exit(
      __status,
    );
  }

  late final _quick_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('quick_exit');
  late final _quick_exit = _quick_exitPtr.asFunction<void Function(int)>();

  void _Exit(
    int __status,
  ) {
    return __Exit(
      __status,
    );
  }

  late final __ExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_Exit');
  late final __Exit = __ExitPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> getenv(
    ffi.Pointer<ffi.Char> __name,
  ) {
    return _getenv(
      __name,
    );
  }

  late final _getenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getenv');
  late final _getenv = _getenvPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int putenv(
    ffi.Pointer<ffi.Char> __string,
  ) {
    return _putenv(
      __string,
    );
  }

  late final _putenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'putenv');
  late final _putenv =
      _putenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int setenv(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __value,
    int __replace,
  ) {
    return _setenv(
      __name,
      __value,
      __replace,
    );
  }

  late final _setenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('setenv');
  late final _setenv = _setenvPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int unsetenv(
    ffi.Pointer<ffi.Char> __name,
  ) {
    return _unsetenv(
      __name,
    );
  }

  late final _unsetenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unsetenv');
  late final _unsetenv =
      _unsetenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int clearenv() {
    return _clearenv();
  }

  late final _clearenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('clearenv');
  late final _clearenv = _clearenvPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> mktemp(
    ffi.Pointer<ffi.Char> __template,
  ) {
    return _mktemp(
      __template,
    );
  }

  late final _mktempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mktemp');
  late final _mktemp = _mktempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mkstemp(
    ffi.Pointer<ffi.Char> __template,
  ) {
    return _mkstemp(
      __template,
    );
  }

  late final _mkstempPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'mkstemp');
  late final _mkstemp =
      _mkstempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int mkstemps(
    ffi.Pointer<ffi.Char> __template,
    int __suffixlen,
  ) {
    return _mkstemps(
      __template,
      __suffixlen,
    );
  }

  late final _mkstempsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'mkstemps');
  late final _mkstemps =
      _mkstempsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> mkdtemp(
    ffi.Pointer<ffi.Char> __template,
  ) {
    return _mkdtemp(
      __template,
    );
  }

  late final _mkdtempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mkdtemp');
  late final _mkdtemp = _mkdtempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int system(
    ffi.Pointer<ffi.Char> __command,
  ) {
    return _system(
      __command,
    );
  }

  late final _systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'system');
  late final _system =
      _systemPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> realpath(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __resolved,
  ) {
    return _realpath(
      __name,
      __resolved,
    );
  }

  late final _realpathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('realpath');
  late final _realpath = _realpathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> bsearch(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nmemb,
    int __size,
    __compar_fn_t __compar,
  ) {
    return _bsearch(
      __key,
      __base,
      __nmemb,
      __size,
      __compar,
    );
  }

  late final _bsearchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              __compar_fn_t)>>('bsearch');
  late final _bsearch = _bsearchPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>, int, int, __compar_fn_t)>();

  void qsort(
    ffi.Pointer<ffi.Void> __base,
    int __nmemb,
    int __size,
    __compar_fn_t __compar,
  ) {
    return _qsort(
      __base,
      __nmemb,
      __size,
      __compar,
    );
  }

  late final _qsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              __compar_fn_t)>>('qsort');
  late final _qsort = _qsortPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, int, int, __compar_fn_t)>();

  int abs(
    int __x,
  ) {
    return _abs(
      __x,
    );
  }

  late final _absPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('abs');
  late final _abs = _absPtr.asFunction<int Function(int)>();

  int labs(
    int __x,
  ) {
    return _labs(
      __x,
    );
  }

  late final _labsPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('labs');
  late final _labs = _labsPtr.asFunction<int Function(int)>();

  int llabs(
    int __x,
  ) {
    return _llabs(
      __x,
    );
  }

  late final _llabsPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.LongLong)>>('llabs');
  late final _llabs = _llabsPtr.asFunction<int Function(int)>();

  div_t div(
    int __numer,
    int __denom,
  ) {
    return _div(
      __numer,
      __denom,
    );
  }

  late final _divPtr =
      _lookup<ffi.NativeFunction<div_t Function(ffi.Int, ffi.Int)>>('div');
  late final _div = _divPtr.asFunction<div_t Function(int, int)>();

  ldiv_t ldiv(
    int __numer,
    int __denom,
  ) {
    return _ldiv(
      __numer,
      __denom,
    );
  }

  late final _ldivPtr =
      _lookup<ffi.NativeFunction<ldiv_t Function(ffi.Long, ffi.Long)>>('ldiv');
  late final _ldiv = _ldivPtr.asFunction<ldiv_t Function(int, int)>();

  lldiv_t lldiv(
    int __numer,
    int __denom,
  ) {
    return _lldiv(
      __numer,
      __denom,
    );
  }

  late final _lldivPtr =
      _lookup<ffi.NativeFunction<lldiv_t Function(ffi.LongLong, ffi.LongLong)>>(
          'lldiv');
  late final _lldiv = _lldivPtr.asFunction<lldiv_t Function(int, int)>();

  ffi.Pointer<ffi.Char> ecvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
  ) {
    return _ecvt(
      __value,
      __ndigit,
      __decpt,
      __sign,
    );
  }

  late final _ecvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('ecvt');
  late final _ecvt = _ecvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> fcvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
  ) {
    return _fcvt(
      __value,
      __ndigit,
      __decpt,
      __sign,
    );
  }

  late final _fcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('fcvt');
  late final _fcvt = _fcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> gcvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Char> __buf,
  ) {
    return _gcvt(
      __value,
      __ndigit,
      __buf,
    );
  }

  late final _gcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Double, ffi.Int, ffi.Pointer<ffi.Char>)>>('gcvt');
  late final _gcvt = _gcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(double, int, ffi.Pointer<ffi.Char>)>();

  int ecvt_r(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
    ffi.Pointer<ffi.Char> __buf,
    int __len,
  ) {
    return _ecvt_r(
      __value,
      __ndigit,
      __decpt,
      __sign,
      __buf,
      __len,
    );
  }

  late final _ecvt_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Double,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('ecvt_r');
  late final _ecvt_r = _ecvt_rPtr.asFunction<
      int Function(double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>, int)>();

  int fcvt_r(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
    ffi.Pointer<ffi.Char> __buf,
    int __len,
  ) {
    return _fcvt_r(
      __value,
      __ndigit,
      __decpt,
      __sign,
      __buf,
      __len,
    );
  }

  late final _fcvt_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Double,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('fcvt_r');
  late final _fcvt_r = _fcvt_rPtr.asFunction<
      int Function(double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>, int)>();

  int mblen(
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mblen(
      __s,
      __n,
    );
  }

  late final _mblenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('mblen');
  late final _mblen =
      _mblenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbtowc(
    ffi.Pointer<ffi.WChar> __pwc,
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mbtowc(
      __pwc,
      __s,
      __n,
    );
  }

  late final _mbtowcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbtowc');
  late final _mbtowc = _mbtowcPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int wctomb(
    ffi.Pointer<ffi.Char> __s,
    int __wchar,
  ) {
    return _wctomb(
      __s,
      __wchar,
    );
  }

  late final _wctombPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.WChar)>>('wctomb');
  late final _wctomb =
      _wctombPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbstowcs(
    ffi.Pointer<ffi.WChar> __pwcs,
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mbstowcs(
      __pwcs,
      __s,
      __n,
    );
  }

  late final _mbstowcsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbstowcs');
  late final _mbstowcs = _mbstowcsPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int wcstombs(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.WChar> __pwcs,
    int __n,
  ) {
    return _wcstombs(
      __s,
      __pwcs,
      __n,
    );
  }

  late final _wcstombsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcstombs');
  late final _wcstombs = _wcstombsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>, int)>();

  int rpmatch(
    ffi.Pointer<ffi.Char> __response,
  ) {
    return _rpmatch(
      __response,
    );
  }

  late final _rpmatchPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rpmatch');
  late final _rpmatch =
      _rpmatchPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __optionp,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __tokens,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __valuep,
  ) {
    return _getsubopt(
      __optionp,
      __tokens,
      __valuep,
    );
  }

  late final _getsuboptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('getsubopt');
  late final _getsubopt = _getsuboptPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int getloadavg(
    ffi.Pointer<ffi.Double> __loadavg,
    int __nelem,
  ) {
    return _getloadavg(
      __loadavg,
      __nelem,
    );
  }

  late final _getloadavgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Double>, ffi.Int)>>('getloadavg');
  late final _getloadavg =
      _getloadavgPtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  /// Determine if the HD Version is public
  ///
  /// \param version HD version
  /// \return true if the version is public, false otherwise
  bool TWHDVersionIsPublic(
    TWHDVersion version,
  ) {
    return _TWHDVersionIsPublic(
      version.value,
    );
  }

  late final _TWHDVersionIsPublicPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.UnsignedInt)>>(
          'TWHDVersionIsPublic');
  late final _TWHDVersionIsPublic =
      _TWHDVersionIsPublicPtr.asFunction<bool Function(int)>();

  /// Determine if the HD Version is private
  ///
  /// \param version HD version
  /// \return true if the version is private, false otherwise
  bool TWHDVersionIsPrivate(
    TWHDVersion version,
  ) {
    return _TWHDVersionIsPrivate(
      version.value,
    );
  }

  late final _TWHDVersionIsPrivatePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.UnsignedInt)>>(
          'TWHDVersionIsPrivate');
  late final _TWHDVersionIsPrivate =
      _TWHDVersionIsPrivatePtr.asFunction<bool Function(int)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BITCOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BITCOIN');

  ffi.Pointer<ffi.Char> get HRP_BITCOIN => _HRP_BITCOIN.value;

  set HRP_BITCOIN(ffi.Pointer<ffi.Char> value) => _HRP_BITCOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_LITECOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_LITECOIN');

  ffi.Pointer<ffi.Char> get HRP_LITECOIN => _HRP_LITECOIN.value;

  set HRP_LITECOIN(ffi.Pointer<ffi.Char> value) => _HRP_LITECOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_VIACOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_VIACOIN');

  ffi.Pointer<ffi.Char> get HRP_VIACOIN => _HRP_VIACOIN.value;

  set HRP_VIACOIN(ffi.Pointer<ffi.Char> value) => _HRP_VIACOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_GROESTLCOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_GROESTLCOIN');

  ffi.Pointer<ffi.Char> get HRP_GROESTLCOIN => _HRP_GROESTLCOIN.value;

  set HRP_GROESTLCOIN(ffi.Pointer<ffi.Char> value) =>
      _HRP_GROESTLCOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_DIGIBYTE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_DIGIBYTE');

  ffi.Pointer<ffi.Char> get HRP_DIGIBYTE => _HRP_DIGIBYTE.value;

  set HRP_DIGIBYTE(ffi.Pointer<ffi.Char> value) => _HRP_DIGIBYTE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_MONACOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_MONACOIN');

  ffi.Pointer<ffi.Char> get HRP_MONACOIN => _HRP_MONACOIN.value;

  set HRP_MONACOIN(ffi.Pointer<ffi.Char> value) => _HRP_MONACOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_COSMOS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_COSMOS');

  ffi.Pointer<ffi.Char> get HRP_COSMOS => _HRP_COSMOS.value;

  set HRP_COSMOS(ffi.Pointer<ffi.Char> value) => _HRP_COSMOS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BITCOINCASH =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BITCOINCASH');

  ffi.Pointer<ffi.Char> get HRP_BITCOINCASH => _HRP_BITCOINCASH.value;

  set HRP_BITCOINCASH(ffi.Pointer<ffi.Char> value) =>
      _HRP_BITCOINCASH.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BITCOINGOLD =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BITCOINGOLD');

  ffi.Pointer<ffi.Char> get HRP_BITCOINGOLD => _HRP_BITCOINGOLD.value;

  set HRP_BITCOINGOLD(ffi.Pointer<ffi.Char> value) =>
      _HRP_BITCOINGOLD.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_IOTEX =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_IOTEX');

  ffi.Pointer<ffi.Char> get HRP_IOTEX => _HRP_IOTEX.value;

  set HRP_IOTEX(ffi.Pointer<ffi.Char> value) => _HRP_IOTEX.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NERVOS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NERVOS');

  ffi.Pointer<ffi.Char> get HRP_NERVOS => _HRP_NERVOS.value;

  set HRP_NERVOS(ffi.Pointer<ffi.Char> value) => _HRP_NERVOS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_ZILLIQA =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_ZILLIQA');

  ffi.Pointer<ffi.Char> get HRP_ZILLIQA => _HRP_ZILLIQA.value;

  set HRP_ZILLIQA(ffi.Pointer<ffi.Char> value) => _HRP_ZILLIQA.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_TERRA =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_TERRA');

  ffi.Pointer<ffi.Char> get HRP_TERRA => _HRP_TERRA.value;

  set HRP_TERRA(ffi.Pointer<ffi.Char> value) => _HRP_TERRA.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_CRYPTOORG =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_CRYPTOORG');

  ffi.Pointer<ffi.Char> get HRP_CRYPTOORG => _HRP_CRYPTOORG.value;

  set HRP_CRYPTOORG(ffi.Pointer<ffi.Char> value) =>
      _HRP_CRYPTOORG.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_KAVA =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_KAVA');

  ffi.Pointer<ffi.Char> get HRP_KAVA => _HRP_KAVA.value;

  set HRP_KAVA(ffi.Pointer<ffi.Char> value) => _HRP_KAVA.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_OASIS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_OASIS');

  ffi.Pointer<ffi.Char> get HRP_OASIS => _HRP_OASIS.value;

  set HRP_OASIS(ffi.Pointer<ffi.Char> value) => _HRP_OASIS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BLUZELLE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BLUZELLE');

  ffi.Pointer<ffi.Char> get HRP_BLUZELLE => _HRP_BLUZELLE.value;

  set HRP_BLUZELLE(ffi.Pointer<ffi.Char> value) => _HRP_BLUZELLE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BAND =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BAND');

  ffi.Pointer<ffi.Char> get HRP_BAND => _HRP_BAND.value;

  set HRP_BAND(ffi.Pointer<ffi.Char> value) => _HRP_BAND.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_ELROND =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_ELROND');

  ffi.Pointer<ffi.Char> get HRP_ELROND => _HRP_ELROND.value;

  set HRP_ELROND(ffi.Pointer<ffi.Char> value) => _HRP_ELROND.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_SECRET =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_SECRET');

  ffi.Pointer<ffi.Char> get HRP_SECRET => _HRP_SECRET.value;

  set HRP_SECRET(ffi.Pointer<ffi.Char> value) => _HRP_SECRET.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_AGORIC =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_AGORIC');

  ffi.Pointer<ffi.Char> get HRP_AGORIC => _HRP_AGORIC.value;

  set HRP_AGORIC(ffi.Pointer<ffi.Char> value) => _HRP_AGORIC.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BINANCE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BINANCE');

  ffi.Pointer<ffi.Char> get HRP_BINANCE => _HRP_BINANCE.value;

  set HRP_BINANCE(ffi.Pointer<ffi.Char> value) => _HRP_BINANCE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_ECASH =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_ECASH');

  ffi.Pointer<ffi.Char> get HRP_ECASH => _HRP_ECASH.value;

  set HRP_ECASH(ffi.Pointer<ffi.Char> value) => _HRP_ECASH.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_THORCHAIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_THORCHAIN');

  ffi.Pointer<ffi.Char> get HRP_THORCHAIN => _HRP_THORCHAIN.value;

  set HRP_THORCHAIN(ffi.Pointer<ffi.Char> value) =>
      _HRP_THORCHAIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_HARMONY =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_HARMONY');

  ffi.Pointer<ffi.Char> get HRP_HARMONY => _HRP_HARMONY.value;

  set HRP_HARMONY(ffi.Pointer<ffi.Char> value) => _HRP_HARMONY.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_CARDANO =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_CARDANO');

  ffi.Pointer<ffi.Char> get HRP_CARDANO => _HRP_CARDANO.value;

  set HRP_CARDANO(ffi.Pointer<ffi.Char> value) => _HRP_CARDANO.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_QTUM =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_QTUM');

  ffi.Pointer<ffi.Char> get HRP_QTUM => _HRP_QTUM.value;

  set HRP_QTUM(ffi.Pointer<ffi.Char> value) => _HRP_QTUM.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NATIVEINJECTIVE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NATIVEINJECTIVE');

  ffi.Pointer<ffi.Char> get HRP_NATIVEINJECTIVE => _HRP_NATIVEINJECTIVE.value;

  set HRP_NATIVEINJECTIVE(ffi.Pointer<ffi.Char> value) =>
      _HRP_NATIVEINJECTIVE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_OSMOSIS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_OSMOSIS');

  ffi.Pointer<ffi.Char> get HRP_OSMOSIS => _HRP_OSMOSIS.value;

  set HRP_OSMOSIS(ffi.Pointer<ffi.Char> value) => _HRP_OSMOSIS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_TERRAV2 =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_TERRAV2');

  ffi.Pointer<ffi.Char> get HRP_TERRAV2 => _HRP_TERRAV2.value;

  set HRP_TERRAV2(ffi.Pointer<ffi.Char> value) => _HRP_TERRAV2.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_COREUM =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_COREUM');

  ffi.Pointer<ffi.Char> get HRP_COREUM => _HRP_COREUM.value;

  set HRP_COREUM(ffi.Pointer<ffi.Char> value) => _HRP_COREUM.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NATIVECANTO =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NATIVECANTO');

  ffi.Pointer<ffi.Char> get HRP_NATIVECANTO => _HRP_NATIVECANTO.value;

  set HRP_NATIVECANTO(ffi.Pointer<ffi.Char> value) =>
      _HRP_NATIVECANTO.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_SOMMELIER =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_SOMMELIER');

  ffi.Pointer<ffi.Char> get HRP_SOMMELIER => _HRP_SOMMELIER.value;

  set HRP_SOMMELIER(ffi.Pointer<ffi.Char> value) =>
      _HRP_SOMMELIER.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_FETCHAI =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_FETCHAI');

  ffi.Pointer<ffi.Char> get HRP_FETCHAI => _HRP_FETCHAI.value;

  set HRP_FETCHAI(ffi.Pointer<ffi.Char> value) => _HRP_FETCHAI.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_MARS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_MARS');

  ffi.Pointer<ffi.Char> get HRP_MARS => _HRP_MARS.value;

  set HRP_MARS(ffi.Pointer<ffi.Char> value) => _HRP_MARS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_UMEE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_UMEE');

  ffi.Pointer<ffi.Char> get HRP_UMEE => _HRP_UMEE.value;

  set HRP_UMEE(ffi.Pointer<ffi.Char> value) => _HRP_UMEE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_QUASAR =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_QUASAR');

  ffi.Pointer<ffi.Char> get HRP_QUASAR => _HRP_QUASAR.value;

  set HRP_QUASAR(ffi.Pointer<ffi.Char> value) => _HRP_QUASAR.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_PERSISTENCE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_PERSISTENCE');

  ffi.Pointer<ffi.Char> get HRP_PERSISTENCE => _HRP_PERSISTENCE.value;

  set HRP_PERSISTENCE(ffi.Pointer<ffi.Char> value) =>
      _HRP_PERSISTENCE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_AKASH =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_AKASH');

  ffi.Pointer<ffi.Char> get HRP_AKASH => _HRP_AKASH.value;

  set HRP_AKASH(ffi.Pointer<ffi.Char> value) => _HRP_AKASH.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NOBLE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NOBLE');

  ffi.Pointer<ffi.Char> get HRP_NOBLE => _HRP_NOBLE.value;

  set HRP_NOBLE(ffi.Pointer<ffi.Char> value) => _HRP_NOBLE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_STARGAZE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_STARGAZE');

  ffi.Pointer<ffi.Char> get HRP_STARGAZE => _HRP_STARGAZE.value;

  set HRP_STARGAZE(ffi.Pointer<ffi.Char> value) => _HRP_STARGAZE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NATIVEEVMOS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NATIVEEVMOS');

  ffi.Pointer<ffi.Char> get HRP_NATIVEEVMOS => _HRP_NATIVEEVMOS.value;

  set HRP_NATIVEEVMOS(ffi.Pointer<ffi.Char> value) =>
      _HRP_NATIVEEVMOS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_JUNO =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_JUNO');

  ffi.Pointer<ffi.Char> get HRP_JUNO => _HRP_JUNO.value;

  set HRP_JUNO(ffi.Pointer<ffi.Char> value) => _HRP_JUNO.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_STRIDE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_STRIDE');

  ffi.Pointer<ffi.Char> get HRP_STRIDE => _HRP_STRIDE.value;

  set HRP_STRIDE(ffi.Pointer<ffi.Char> value) => _HRP_STRIDE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_AXELAR =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_AXELAR');

  ffi.Pointer<ffi.Char> get HRP_AXELAR => _HRP_AXELAR.value;

  set HRP_AXELAR(ffi.Pointer<ffi.Char> value) => _HRP_AXELAR.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_CRESCENT =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_CRESCENT');

  ffi.Pointer<ffi.Char> get HRP_CRESCENT => _HRP_CRESCENT.value;

  set HRP_CRESCENT(ffi.Pointer<ffi.Char> value) => _HRP_CRESCENT.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_KUJIRA =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_KUJIRA');

  ffi.Pointer<ffi.Char> get HRP_KUJIRA => _HRP_KUJIRA.value;

  set HRP_KUJIRA(ffi.Pointer<ffi.Char> value) => _HRP_KUJIRA.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_COMDEX =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_COMDEX');

  ffi.Pointer<ffi.Char> get HRP_COMDEX => _HRP_COMDEX.value;

  set HRP_COMDEX(ffi.Pointer<ffi.Char> value) => _HRP_COMDEX.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NEUTRON =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NEUTRON');

  ffi.Pointer<ffi.Char> get HRP_NEUTRON => _HRP_NEUTRON.value;

  set HRP_NEUTRON(ffi.Pointer<ffi.Char> value) => _HRP_NEUTRON.value = value;

  ffi.Pointer<ffi.Char> stringForHRP(
    TWHRP hrp,
  ) {
    return _stringForHRP(
      hrp.value,
    );
  }

  late final _stringForHRPPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'stringForHRP');
  late final _stringForHRP =
      _stringForHRPPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  TWHRP hrpForString(
    ffi.Pointer<ffi.Char> string,
  ) {
    return TWHRP.fromValue(_hrpForString(
      string,
    ));
  }

  late final _hrpForStringPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<ffi.Char>)>>(
      'hrpForString');
  late final _hrpForString =
      _hrpForStringPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Creates a string from a null-terminated UTF8 byte array. It must be deleted at the end.
  ffi.Pointer<TWString> TWStringCreateWithUTF8Bytes(
    ffi.Pointer<ffi.Char> bytes,
  ) {
    return _TWStringCreateWithUTF8Bytes(
      bytes,
    );
  }

  late final _TWStringCreateWithUTF8BytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<ffi.Char>)>>('TWStringCreateWithUTF8Bytes');
  late final _TWStringCreateWithUTF8Bytes = _TWStringCreateWithUTF8BytesPtr
      .asFunction<ffi.Pointer<TWString> Function(ffi.Pointer<ffi.Char>)>();

  /// Creates a string from a raw byte array and size.
  ffi.Pointer<TWString> TWStringCreateWithRawBytes(
    ffi.Pointer<ffi.Uint8> bytes,
    int size,
  ) {
    return _TWStringCreateWithRawBytes(
      bytes,
      size,
    );
  }

  late final _TWStringCreateWithRawBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('TWStringCreateWithRawBytes');
  late final _TWStringCreateWithRawBytes =
      _TWStringCreateWithRawBytesPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Creates a hexadecimal string from a block of data. It must be deleted at the end.
  ffi.Pointer<TWString> TWStringCreateWithHexData(
    ffi.Pointer<TWData> data,
  ) {
    return _TWStringCreateWithHexData(
      data,
    );
  }

  late final _TWStringCreateWithHexDataPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>>(
      'TWStringCreateWithHexData');
  late final _TWStringCreateWithHexData = _TWStringCreateWithHexDataPtr
      .asFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>();

  /// Returns the string size in bytes.
  int TWStringSize(
    ffi.Pointer<TWString> string,
  ) {
    return _TWStringSize(
      string,
    );
  }

  late final _TWStringSizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<TWString>)>>(
          'TWStringSize');
  late final _TWStringSize =
      _TWStringSizePtr.asFunction<int Function(ffi.Pointer<TWString>)>();

  /// Returns the byte at the provided index.
  int TWStringGet(
    ffi.Pointer<TWString> string,
    int index,
  ) {
    return _TWStringGet(
      string,
      index,
    );
  }

  late final _TWStringGetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Char Function(ffi.Pointer<TWString>, ffi.Size)>>('TWStringGet');
  late final _TWStringGet =
      _TWStringGetPtr.asFunction<int Function(ffi.Pointer<TWString>, int)>();

  /// Returns the raw pointer to the string's UTF8 bytes (null-terminated).
  ffi.Pointer<ffi.Char> TWStringUTF8Bytes(
    ffi.Pointer<TWString> string,
  ) {
    return _TWStringUTF8Bytes(
      string,
    );
  }

  late final _TWStringUTF8BytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<TWString>)>>('TWStringUTF8Bytes');
  late final _TWStringUTF8Bytes = _TWStringUTF8BytesPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<TWString>)>();

  /// Deletes a string created with a `TWStringCreate*` method.  After delete it must not be used (can segfault)!
  void TWStringDelete(
    ffi.Pointer<TWString> string,
  ) {
    return _TWStringDelete(
      string,
    );
  }

  late final _TWStringDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWString>)>>(
          'TWStringDelete');
  late final _TWStringDelete =
      _TWStringDeletePtr.asFunction<void Function(ffi.Pointer<TWString>)>();

  /// Determines whether two string blocks are equal.
  bool TWStringEqual(
    ffi.Pointer<TWString> lhs,
    ffi.Pointer<TWString> rhs,
  ) {
    return _TWStringEqual(
      lhs,
      rhs,
    );
  }

  late final _TWStringEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWString>)>>('TWStringEqual');
  late final _TWStringEqual = _TWStringEqualPtr.asFunction<
      bool Function(ffi.Pointer<TWString>, ffi.Pointer<TWString>)>();

  /// Returns the blockchain for a coin type.
  ///
  /// \param coin A coin type
  /// \return blockchain associated to the given coin type
  TWBlockchain TWCoinTypeBlockchain(
    TWCoinType coin,
  ) {
    return TWBlockchain.fromValue(_TWCoinTypeBlockchain(
      coin.value,
    ));
  }

  late final _TWCoinTypeBlockchainPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'TWCoinTypeBlockchain');
  late final _TWCoinTypeBlockchain =
      _TWCoinTypeBlockchainPtr.asFunction<int Function(int)>();

  /// Returns the purpose for a coin type.
  ///
  /// \param coin A coin type
  /// \return purpose associated to the given coin type
  TWPurpose TWCoinTypePurpose(
    TWCoinType coin,
  ) {
    return TWPurpose.fromValue(_TWCoinTypePurpose(
      coin.value,
    ));
  }

  late final _TWCoinTypePurposePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'TWCoinTypePurpose');
  late final _TWCoinTypePurpose =
      _TWCoinTypePurposePtr.asFunction<int Function(int)>();

  /// Returns the curve that should be used for a coin type.
  ///
  /// \param coin A coin type
  /// \return curve that should be used for the given coin type
  TWCurve TWCoinTypeCurve(
    TWCoinType coin,
  ) {
    return TWCurve.fromValue(_TWCoinTypeCurve(
      coin.value,
    ));
  }

  late final _TWCoinTypeCurvePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'TWCoinTypeCurve');
  late final _TWCoinTypeCurve =
      _TWCoinTypeCurvePtr.asFunction<int Function(int)>();

  /// Returns the xpub HD version that should be used for a coin type.
  ///
  /// \param coin A coin type
  /// \return xpub HD version that should be used for the given coin type
  TWHDVersion TWCoinTypeXpubVersion(
    TWCoinType coin,
  ) {
    return TWHDVersion.fromValue(_TWCoinTypeXpubVersion(
      coin.value,
    ));
  }

  late final _TWCoinTypeXpubVersionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'TWCoinTypeXpubVersion');
  late final _TWCoinTypeXpubVersion =
      _TWCoinTypeXpubVersionPtr.asFunction<int Function(int)>();

  /// Returns the xprv HD version that should be used for a coin type.
  ///
  /// \param coin A coin type
  /// \return the xprv HD version that should be used for the given coin type.
  TWHDVersion TWCoinTypeXprvVersion(
    TWCoinType coin,
  ) {
    return TWHDVersion.fromValue(_TWCoinTypeXprvVersion(
      coin.value,
    ));
  }

  late final _TWCoinTypeXprvVersionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'TWCoinTypeXprvVersion');
  late final _TWCoinTypeXprvVersion =
      _TWCoinTypeXprvVersionPtr.asFunction<int Function(int)>();

  /// Validates an address string.
  ///
  /// \param coin A coin type
  /// \param address A public address
  /// \return true if the address is a valid public address of the given coin, false otherwise.
  bool TWCoinTypeValidate(
    TWCoinType coin,
    ffi.Pointer<TWString> address,
  ) {
    return _TWCoinTypeValidate(
      coin.value,
      address,
    );
  }

  late final _TWCoinTypeValidatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.UnsignedInt, ffi.Pointer<TWString>)>>('TWCoinTypeValidate');
  late final _TWCoinTypeValidate = _TWCoinTypeValidatePtr.asFunction<
      bool Function(int, ffi.Pointer<TWString>)>();

  /// Returns the default derivation path for a particular coin.
  ///
  /// \param coin A coin type
  /// \return the default derivation path for the given coin type.
  ffi.Pointer<TWString> TWCoinTypeDerivationPath(
    TWCoinType coin,
  ) {
    return _TWCoinTypeDerivationPath(
      coin.value,
    );
  }

  late final _TWCoinTypeDerivationPathPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<TWString> Function(ffi.UnsignedInt)>>(
      'TWCoinTypeDerivationPath');
  late final _TWCoinTypeDerivationPath = _TWCoinTypeDerivationPathPtr
      .asFunction<ffi.Pointer<TWString> Function(int)>();

  /// Returns the derivation path for a particular coin with the explicit given derivation.
  ///
  /// \param coin A coin type
  /// \param derivation A derivation type
  /// \return the derivation path for the given coin with the explicit given derivation
  ffi.Pointer<TWString> TWCoinTypeDerivationPathWithDerivation(
    TWCoinType coin,
    TWDerivation derivation,
  ) {
    return _TWCoinTypeDerivationPathWithDerivation(
      coin.value,
      derivation.value,
    );
  }

  late final _TWCoinTypeDerivationPathWithDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWCoinTypeDerivationPathWithDerivation');
  late final _TWCoinTypeDerivationPathWithDerivation =
      _TWCoinTypeDerivationPathWithDerivationPtr.asFunction<
          ffi.Pointer<TWString> Function(int, int)>();

  /// Derives the address for a particular coin from the private key.
  ///
  /// \param coin A coin type
  /// \param privateKey A valid private key
  /// \return Derived address for the given coin from the private key.
  ffi.Pointer<TWString> TWCoinTypeDeriveAddress(
    TWCoinType coin,
    ffi.Pointer<TWPrivateKey> privateKey,
  ) {
    return _TWCoinTypeDeriveAddress(
      coin.value,
      privateKey,
    );
  }

  late final _TWCoinTypeDeriveAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.UnsignedInt,
              ffi.Pointer<TWPrivateKey>)>>('TWCoinTypeDeriveAddress');
  late final _TWCoinTypeDeriveAddress = _TWCoinTypeDeriveAddressPtr.asFunction<
      ffi.Pointer<TWString> Function(int, ffi.Pointer<TWPrivateKey>)>();

  /// Derives the address for a particular coin from the public key.
  ///
  /// \param coin A coin type
  /// \param publicKey A valid public key
  /// \return Derived address for the given coin from the public key.
  ffi.Pointer<TWString> TWCoinTypeDeriveAddressFromPublicKey(
    TWCoinType coin,
    ffi.Pointer<TWPublicKey> publicKey,
  ) {
    return _TWCoinTypeDeriveAddressFromPublicKey(
      coin.value,
      publicKey,
    );
  }

  late final _TWCoinTypeDeriveAddressFromPublicKeyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString> Function(
                  ffi.UnsignedInt, ffi.Pointer<TWPublicKey>)>>(
      'TWCoinTypeDeriveAddressFromPublicKey');
  late final _TWCoinTypeDeriveAddressFromPublicKey =
      _TWCoinTypeDeriveAddressFromPublicKeyPtr.asFunction<
          ffi.Pointer<TWString> Function(int, ffi.Pointer<TWPublicKey>)>();

  /// HRP for this coin type
  ///
  /// \param coin A coin type
  /// \return HRP of the given coin type.
  TWHRP TWCoinTypeHRP(
    TWCoinType coin,
  ) {
    return TWHRP.fromValue(_TWCoinTypeHRP(
      coin.value,
    ));
  }

  late final _TWCoinTypeHRPPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'TWCoinTypeHRP');
  late final _TWCoinTypeHRP = _TWCoinTypeHRPPtr.asFunction<int Function(int)>();

  /// P2PKH prefix for this coin type
  ///
  /// \param coin A coin type
  /// \return P2PKH prefix for the given coin type
  int TWCoinTypeP2pkhPrefix(
    TWCoinType coin,
  ) {
    return _TWCoinTypeP2pkhPrefix(
      coin.value,
    );
  }

  late final _TWCoinTypeP2pkhPrefixPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.UnsignedInt)>>(
          'TWCoinTypeP2pkhPrefix');
  late final _TWCoinTypeP2pkhPrefix =
      _TWCoinTypeP2pkhPrefixPtr.asFunction<int Function(int)>();

  /// P2SH prefix for this coin type
  ///
  /// \param coin A coin type
  /// \return P2SH prefix for the given coin type
  int TWCoinTypeP2shPrefix(
    TWCoinType coin,
  ) {
    return _TWCoinTypeP2shPrefix(
      coin.value,
    );
  }

  late final _TWCoinTypeP2shPrefixPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.UnsignedInt)>>(
          'TWCoinTypeP2shPrefix');
  late final _TWCoinTypeP2shPrefix =
      _TWCoinTypeP2shPrefixPtr.asFunction<int Function(int)>();

  /// Static prefix for this coin type
  ///
  /// \param coin A coin type
  /// \return Static prefix for the given coin type
  int TWCoinTypeStaticPrefix(
    TWCoinType coin,
  ) {
    return _TWCoinTypeStaticPrefix(
      coin.value,
    );
  }

  late final _TWCoinTypeStaticPrefixPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.UnsignedInt)>>(
          'TWCoinTypeStaticPrefix');
  late final _TWCoinTypeStaticPrefix =
      _TWCoinTypeStaticPrefixPtr.asFunction<int Function(int)>();

  /// ChainID for this coin type.
  ///
  /// \param coin A coin type
  /// \return ChainID for the given coin type.
  /// \note Caller must free returned object.
  ffi.Pointer<TWString> TWCoinTypeChainId(
    TWCoinType coin,
  ) {
    return _TWCoinTypeChainId(
      coin.value,
    );
  }

  late final _TWCoinTypeChainIdPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<TWString> Function(ffi.UnsignedInt)>>(
      'TWCoinTypeChainId');
  late final _TWCoinTypeChainId =
      _TWCoinTypeChainIdPtr.asFunction<ffi.Pointer<TWString> Function(int)>();

  /// SLIP-0044 id for this coin type
  ///
  /// \param coin A coin type
  /// \return SLIP-0044 id for the given coin type
  int TWCoinTypeSlip44Id(
    TWCoinType coin,
  ) {
    return _TWCoinTypeSlip44Id(
      coin.value,
    );
  }

  late final _TWCoinTypeSlip44IdPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.UnsignedInt)>>(
          'TWCoinTypeSlip44Id');
  late final _TWCoinTypeSlip44Id =
      _TWCoinTypeSlip44IdPtr.asFunction<int Function(int)>();

  /// SS58Prefix for this coin type
  ///
  /// \param coin A coin type
  /// \return SS58Prefix for the given coin type
  int TWCoinTypeSS58Prefix(
    TWCoinType coin,
  ) {
    return _TWCoinTypeSS58Prefix(
      coin.value,
    );
  }

  late final _TWCoinTypeSS58PrefixPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.UnsignedInt)>>(
          'TWCoinTypeSS58Prefix');
  late final _TWCoinTypeSS58Prefix =
      _TWCoinTypeSS58PrefixPtr.asFunction<int Function(int)>();

  /// public key type for this coin type
  ///
  /// \param coin A coin type
  /// \return public key type for the given coin type
  TWPublicKeyType TWCoinTypePublicKeyType(
    TWCoinType coin,
  ) {
    return TWPublicKeyType.fromValue(_TWCoinTypePublicKeyType(
      coin.value,
    ));
  }

  late final _TWCoinTypePublicKeyTypePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'TWCoinTypePublicKeyType');
  late final _TWCoinTypePublicKeyType =
      _TWCoinTypePublicKeyTypePtr.asFunction<int Function(int)>();

  /// Creates a block of data from a byte array.
  ///
  /// \param bytes Non-null raw bytes buffer
  /// \param size size of the buffer
  /// \return Non-null filled block of data.
  ffi.Pointer<TWData> TWDataCreateWithBytes(
    ffi.Pointer<ffi.Uint8> bytes,
    int size,
  ) {
    return _TWDataCreateWithBytes(
      bytes,
      size,
    );
  }

  late final _TWDataCreateWithBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('TWDataCreateWithBytes');
  late final _TWDataCreateWithBytes = _TWDataCreateWithBytesPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Creates an uninitialized block of data with the provided size.
  ///
  /// \param size size for the block of data
  /// \return Non-null uninitialized block of data with the provided size
  ffi.Pointer<TWData> TWDataCreateWithSize(
    int size,
  ) {
    return _TWDataCreateWithSize(
      size,
    );
  }

  late final _TWDataCreateWithSizePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWData> Function(ffi.Size)>>(
          'TWDataCreateWithSize');
  late final _TWDataCreateWithSize =
      _TWDataCreateWithSizePtr.asFunction<ffi.Pointer<TWData> Function(int)>();

  /// Creates a block of data by copying another block of data.
  ///
  /// \param data buffer that need to be copied
  /// \return Non-null filled block of data.
  ffi.Pointer<TWData> TWDataCreateWithData(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataCreateWithData(
      data,
    );
  }

  late final _TWDataCreateWithDataPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWDataCreateWithData');
  late final _TWDataCreateWithData = _TWDataCreateWithDataPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Creates a block of data from a hexadecimal string.  Odd length is invalid (intended grouping to bytes is not obvious).
  ///
  /// \param hex input hex string
  /// \return Non-null filled block of data
  ffi.Pointer<TWData> TWDataCreateWithHexString(
    ffi.Pointer<TWString> hex,
  ) {
    return _TWDataCreateWithHexString(
      hex,
    );
  }

  late final _TWDataCreateWithHexStringPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>>(
      'TWDataCreateWithHexString');
  late final _TWDataCreateWithHexString = _TWDataCreateWithHexStringPtr
      .asFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>();

  /// Returns the size in bytes.
  ///
  /// \param data A non-null valid block of data
  /// \return the size of the given block of data
  int TWDataSize(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataSize(
      data,
    );
  }

  late final _TWDataSizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<TWData>)>>(
          'TWDataSize');
  late final _TWDataSize =
      _TWDataSizePtr.asFunction<int Function(ffi.Pointer<TWData>)>();

  /// Returns the raw pointer to the contents of data.
  ///
  /// \param data A non-null valid block of data
  /// \return the raw pointer to the contents of data
  ffi.Pointer<ffi.Uint8> TWDataBytes(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataBytes(
      data,
    );
  }

  late final _TWDataBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<TWData>)>>('TWDataBytes');
  late final _TWDataBytes = _TWDataBytesPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<TWData>)>();

  /// Returns the byte at the provided index.
  ///
  /// \param data A non-null valid block of data
  /// \param index index of the byte that we want to fetch - index need to be < TWDataSize(data)
  /// \return the byte at the provided index
  int TWDataGet(
    ffi.Pointer<TWData> data,
    int index,
  ) {
    return _TWDataGet(
      data,
      index,
    );
  }

  late final _TWDataGetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<TWData>, ffi.Size)>>('TWDataGet');
  late final _TWDataGet =
      _TWDataGetPtr.asFunction<int Function(ffi.Pointer<TWData>, int)>();

  /// Sets the byte at the provided index.
  ///
  /// \param data A non-null valid block of data
  /// \param index index of the byte that we want to set - index need to be < TWDataSize(data)
  /// \param byte Given byte to be written in data
  void TWDataSet(
    ffi.Pointer<TWData> data,
    int index,
    int byte,
  ) {
    return _TWDataSet(
      data,
      index,
      byte,
    );
  }

  late final _TWDataSetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<TWData>, ffi.Size, ffi.Uint8)>>('TWDataSet');
  late final _TWDataSet =
      _TWDataSetPtr.asFunction<void Function(ffi.Pointer<TWData>, int, int)>();

  /// Copies a range of bytes into the provided buffer.
  ///
  /// \param data A non-null valid block of data
  /// \param start starting index of the range - index need to be < TWDataSize(data)
  /// \param size size of the range we want to copy - size need to be < TWDataSize(data) - start
  /// \param output The output buffer where we want to copy the data.
  void TWDataCopyBytes(
    ffi.Pointer<TWData> data,
    int start,
    int size,
    ffi.Pointer<ffi.Uint8> output,
  ) {
    return _TWDataCopyBytes(
      data,
      start,
      size,
      output,
    );
  }

  late final _TWDataCopyBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWData>, ffi.Size, ffi.Size,
              ffi.Pointer<ffi.Uint8>)>>('TWDataCopyBytes');
  late final _TWDataCopyBytes = _TWDataCopyBytesPtr.asFunction<
      void Function(ffi.Pointer<TWData>, int, int, ffi.Pointer<ffi.Uint8>)>();

  /// Replaces a range of bytes with the contents of the provided buffer.
  ///
  /// \param data A non-null valid block of data
  /// \param start starting index of the range - index need to be < TWDataSize(data)
  /// \param size size of the range we want to replace - size need to be < TWDataSize(data) - start
  /// \param bytes The buffer that will replace the range of data
  void TWDataReplaceBytes(
    ffi.Pointer<TWData> data,
    int start,
    int size,
    ffi.Pointer<ffi.Uint8> bytes,
  ) {
    return _TWDataReplaceBytes(
      data,
      start,
      size,
      bytes,
    );
  }

  late final _TWDataReplaceBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWData>, ffi.Size, ffi.Size,
              ffi.Pointer<ffi.Uint8>)>>('TWDataReplaceBytes');
  late final _TWDataReplaceBytes = _TWDataReplaceBytesPtr.asFunction<
      void Function(ffi.Pointer<TWData>, int, int, ffi.Pointer<ffi.Uint8>)>();

  /// Appends data from a byte array.
  ///
  /// \param data A non-null valid block of data
  /// \param bytes Non-null byte array
  /// \param size The size of the byte array
  void TWDataAppendBytes(
    ffi.Pointer<TWData> data,
    ffi.Pointer<ffi.Uint8> bytes,
    int size,
  ) {
    return _TWDataAppendBytes(
      data,
      bytes,
      size,
    );
  }

  late final _TWDataAppendBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWData>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('TWDataAppendBytes');
  late final _TWDataAppendBytes = _TWDataAppendBytesPtr.asFunction<
      void Function(ffi.Pointer<TWData>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Appends a single byte.
  ///
  /// \param data A non-null valid block of data
  /// \param byte A single byte
  void TWDataAppendByte(
    ffi.Pointer<TWData> data,
    int byte,
  ) {
    return _TWDataAppendByte(
      data,
      byte,
    );
  }

  late final _TWDataAppendBytePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<TWData>, ffi.Uint8)>>(
      'TWDataAppendByte');
  late final _TWDataAppendByte = _TWDataAppendBytePtr.asFunction<
      void Function(ffi.Pointer<TWData>, int)>();

  /// Appends a block of data.
  ///
  /// \param data A non-null valid block of data
  /// \param append A non-null valid block of data
  void TWDataAppendData(
    ffi.Pointer<TWData> data,
    ffi.Pointer<TWData> append,
  ) {
    return _TWDataAppendData(
      data,
      append,
    );
  }

  late final _TWDataAppendDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<TWData>, ffi.Pointer<TWData>)>>('TWDataAppendData');
  late final _TWDataAppendData = _TWDataAppendDataPtr.asFunction<
      void Function(ffi.Pointer<TWData>, ffi.Pointer<TWData>)>();

  /// Reverse the bytes.
  ///
  /// \param data A non-null valid block of data
  void TWDataReverse(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataReverse(
      data,
    );
  }

  late final _TWDataReversePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWData>)>>(
          'TWDataReverse');
  late final _TWDataReverse =
      _TWDataReversePtr.asFunction<void Function(ffi.Pointer<TWData>)>();

  /// Sets all bytes to the given value.
  ///
  /// \param data A non-null valid block of data
  void TWDataReset(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataReset(
      data,
    );
  }

  late final _TWDataResetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWData>)>>(
          'TWDataReset');
  late final _TWDataReset =
      _TWDataResetPtr.asFunction<void Function(ffi.Pointer<TWData>)>();

  /// Deletes a block of data created with a `TWDataCreate*` method.
  ///
  /// \param data A non-null valid block of data
  void TWDataDelete(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataDelete(
      data,
    );
  }

  late final _TWDataDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWData>)>>(
          'TWDataDelete');
  late final _TWDataDelete =
      _TWDataDeletePtr.asFunction<void Function(ffi.Pointer<TWData>)>();

  /// Determines whether two data blocks are equal.
  ///
  /// \param lhs left non null block of data to be compared
  /// \param rhs right non null block of data to be compared
  /// \return true if both block of data are equal, false otherwise
  bool TWDataEqual(
    ffi.Pointer<TWData> lhs,
    ffi.Pointer<TWData> rhs,
  ) {
    return _TWDataEqual(
      lhs,
      rhs,
    );
  }

  late final _TWDataEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<TWData>, ffi.Pointer<TWData>)>>('TWDataEqual');
  late final _TWDataEqual = _TWDataEqualPtr.asFunction<
      bool Function(ffi.Pointer<TWData>, ffi.Pointer<TWData>)>();

  /// Compares two addresses for equality.
  ///
  /// \param lhs The first address to compare.
  /// \param rhs The second address to compare.
  /// \return bool indicating the addresses are equal.
  bool TWAnyAddressEqual(
    ffi.Pointer<TWAnyAddress> lhs,
    ffi.Pointer<TWAnyAddress> rhs,
  ) {
    return _TWAnyAddressEqual(
      lhs,
      rhs,
    );
  }

  late final _TWAnyAddressEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWAnyAddress>,
              ffi.Pointer<TWAnyAddress>)>>('TWAnyAddressEqual');
  late final _TWAnyAddressEqual = _TWAnyAddressEqualPtr.asFunction<
      bool Function(ffi.Pointer<TWAnyAddress>, ffi.Pointer<TWAnyAddress>)>();

  /// Determines if the string is a valid Any address.
  ///
  /// \param string address to validate.
  /// \param coin coin type of the address.
  /// \return bool indicating if the address is valid.
  bool TWAnyAddressIsValid(
    ffi.Pointer<TWString> string,
    TWCoinType coin,
  ) {
    return _TWAnyAddressIsValid(
      string,
      coin.value,
    );
  }

  late final _TWAnyAddressIsValidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<TWString>, ffi.UnsignedInt)>>('TWAnyAddressIsValid');
  late final _TWAnyAddressIsValid = _TWAnyAddressIsValidPtr.asFunction<
      bool Function(ffi.Pointer<TWString>, int)>();

  /// Determines if the string is a valid Any address with the given hrp.
  ///
  /// \param string address to validate.
  /// \param coin coin type of the address.
  /// \param hrp explicit given hrp of the given address.
  /// \return bool indicating if the address is valid.
  bool TWAnyAddressIsValidBech32(
    ffi.Pointer<TWString> string,
    TWCoinType coin,
    ffi.Pointer<TWString> hrp,
  ) {
    return _TWAnyAddressIsValidBech32(
      string,
      coin.value,
      hrp,
    );
  }

  late final _TWAnyAddressIsValidBech32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWString>, ffi.UnsignedInt,
              ffi.Pointer<TWString>)>>('TWAnyAddressIsValidBech32');
  late final _TWAnyAddressIsValidBech32 =
      _TWAnyAddressIsValidBech32Ptr.asFunction<
          bool Function(ffi.Pointer<TWString>, int, ffi.Pointer<TWString>)>();

  /// Determines if the string is a valid Any address with the given SS58 network prefix.
  ///
  /// \param string address to validate.
  /// \param coin coin type of the address.
  /// \param ss58Prefix ss58Prefix of the given address.
  /// \return bool indicating if the address is valid.
  bool TWAnyAddressIsValidSS58(
    ffi.Pointer<TWString> string,
    TWCoinType coin,
    int ss58Prefix,
  ) {
    return _TWAnyAddressIsValidSS58(
      string,
      coin.value,
      ss58Prefix,
    );
  }

  late final _TWAnyAddressIsValidSS58Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWString>, ffi.UnsignedInt,
              ffi.Uint32)>>('TWAnyAddressIsValidSS58');
  late final _TWAnyAddressIsValidSS58 = _TWAnyAddressIsValidSS58Ptr.asFunction<
      bool Function(ffi.Pointer<TWString>, int, int)>();

  /// Creates an address from a string representation and a coin type. Must be deleted with TWAnyAddressDelete after use.
  ///
  /// \param string address to create.
  /// \param coin coin type of the address.
  /// \return TWAnyAddress pointer or nullptr if address and coin are invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateWithString(
    ffi.Pointer<TWString> string,
    TWCoinType coin,
  ) {
    return _TWAnyAddressCreateWithString(
      string,
      coin.value,
    );
  }

  late final _TWAnyAddressCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWString>,
              ffi.UnsignedInt)>>('TWAnyAddressCreateWithString');
  late final _TWAnyAddressCreateWithString =
      _TWAnyAddressCreateWithStringPtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWString>, int)>();

  /// Creates an bech32 address from a string representation, a coin type and the given hrp. Must be deleted with TWAnyAddressDelete after use.
  ///
  /// \param string address to create.
  /// \param coin coin type of the address.
  /// \param hrp hrp of the address.
  /// \return TWAnyAddress pointer or nullptr if address and coin are invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateBech32(
    ffi.Pointer<TWString> string,
    TWCoinType coin,
    ffi.Pointer<TWString> hrp,
  ) {
    return _TWAnyAddressCreateBech32(
      string,
      coin.value,
      hrp,
    );
  }

  late final _TWAnyAddressCreateBech32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWString>,
              ffi.UnsignedInt,
              ffi.Pointer<TWString>)>>('TWAnyAddressCreateBech32');
  late final _TWAnyAddressCreateBech32 =
      _TWAnyAddressCreateBech32Ptr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWString>, int, ffi.Pointer<TWString>)>();

  /// Creates an SS58 address from a string representation, a coin type and the given ss58Prefix. Must be deleted with TWAnyAddressDelete after use.
  ///
  /// \param string address to create.
  /// \param coin coin type of the address.
  /// \param ss58Prefix ss58Prefix of the SS58 address.
  /// \return TWAnyAddress pointer or nullptr if address and coin are invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateSS58(
    ffi.Pointer<TWString> string,
    TWCoinType coin,
    int ss58Prefix,
  ) {
    return _TWAnyAddressCreateSS58(
      string,
      coin.value,
      ss58Prefix,
    );
  }

  late final _TWAnyAddressCreateSS58Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWString>,
              ffi.UnsignedInt, ffi.Uint32)>>('TWAnyAddressCreateSS58');
  late final _TWAnyAddressCreateSS58 = _TWAnyAddressCreateSS58Ptr.asFunction<
      ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWString>, int, int)>();

  /// Creates an address from a public key.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param coin coin type of the address.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateWithPublicKey(
    ffi.Pointer<TWPublicKey> publicKey,
    TWCoinType coin,
  ) {
    return _TWAnyAddressCreateWithPublicKey(
      publicKey,
      coin.value,
    );
  }

  late final _TWAnyAddressCreateWithPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWPublicKey>,
              ffi.UnsignedInt)>>('TWAnyAddressCreateWithPublicKey');
  late final _TWAnyAddressCreateWithPublicKey =
      _TWAnyAddressCreateWithPublicKeyPtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWPublicKey>, int)>();

  /// Creates an address from a public key and derivation option.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param coin coin type of the address.
  /// \param derivation the custom derivation to use.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateWithPublicKeyDerivation(
    ffi.Pointer<TWPublicKey> publicKey,
    TWCoinType coin,
    TWDerivation derivation,
  ) {
    return _TWAnyAddressCreateWithPublicKeyDerivation(
      publicKey,
      coin.value,
      derivation.value,
    );
  }

  late final _TWAnyAddressCreateWithPublicKeyDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWPublicKey>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWAnyAddressCreateWithPublicKeyDerivation');
  late final _TWAnyAddressCreateWithPublicKeyDerivation =
      _TWAnyAddressCreateWithPublicKeyDerivationPtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWPublicKey>, int, int)>();

  /// Creates an bech32 address from a public key and a given hrp.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param coin coin type of the address.
  /// \param hrp hrp of the address.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateBech32WithPublicKey(
    ffi.Pointer<TWPublicKey> publicKey,
    TWCoinType coin,
    ffi.Pointer<TWString> hrp,
  ) {
    return _TWAnyAddressCreateBech32WithPublicKey(
      publicKey,
      coin.value,
      hrp,
    );
  }

  late final _TWAnyAddressCreateBech32WithPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWPublicKey>,
              ffi.UnsignedInt,
              ffi.Pointer<TWString>)>>('TWAnyAddressCreateBech32WithPublicKey');
  late final _TWAnyAddressCreateBech32WithPublicKey =
      _TWAnyAddressCreateBech32WithPublicKeyPtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWPublicKey>, int, ffi.Pointer<TWString>)>();

  /// Creates an SS58 address from a public key and a given ss58Prefix.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param coin coin type of the address.
  /// \param ss58Prefix ss58Prefix of the SS58 address.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateSS58WithPublicKey(
    ffi.Pointer<TWPublicKey> publicKey,
    TWCoinType coin,
    int ss58Prefix,
  ) {
    return _TWAnyAddressCreateSS58WithPublicKey(
      publicKey,
      coin.value,
      ss58Prefix,
    );
  }

  late final _TWAnyAddressCreateSS58WithPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWPublicKey>,
              ffi.UnsignedInt,
              ffi.Uint32)>>('TWAnyAddressCreateSS58WithPublicKey');
  late final _TWAnyAddressCreateSS58WithPublicKey =
      _TWAnyAddressCreateSS58WithPublicKeyPtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWPublicKey>, int, int)>();

  /// Creates a Filecoin address from a public key and a given address type.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param filecoinAddressType Filecoin address type.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateWithPublicKeyFilecoinAddressType(
    ffi.Pointer<TWPublicKey> publicKey,
    TWFilecoinAddressType filecoinAddressType,
  ) {
    return _TWAnyAddressCreateWithPublicKeyFilecoinAddressType(
      publicKey,
      filecoinAddressType.value,
    );
  }

  late final _TWAnyAddressCreateWithPublicKeyFilecoinAddressTypePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWAnyAddress> Function(
                  ffi.Pointer<TWPublicKey>, ffi.UnsignedInt)>>(
      'TWAnyAddressCreateWithPublicKeyFilecoinAddressType');
  late final _TWAnyAddressCreateWithPublicKeyFilecoinAddressType =
      _TWAnyAddressCreateWithPublicKeyFilecoinAddressTypePtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWPublicKey>, int)>();

  /// Deletes an address.
  ///
  /// \param address address to delete.
  void TWAnyAddressDelete(
    ffi.Pointer<TWAnyAddress> address,
  ) {
    return _TWAnyAddressDelete(
      address,
    );
  }

  late final _TWAnyAddressDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWAnyAddress>)>>(
          'TWAnyAddressDelete');
  late final _TWAnyAddressDelete = _TWAnyAddressDeletePtr.asFunction<
      void Function(ffi.Pointer<TWAnyAddress>)>();

  /// Returns the address string representation.
  ///
  /// \param address address to get the string representation of.
  ffi.Pointer<TWString> TWAnyAddressDescription(
    ffi.Pointer<TWAnyAddress> address,
  ) {
    return _TWAnyAddressDescription(
      address,
    );
  }

  late final _TWAnyAddressDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWAnyAddress>)>>('TWAnyAddressDescription');
  late final _TWAnyAddressDescription = _TWAnyAddressDescriptionPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWAnyAddress>)>();

  /// Returns coin type of address.
  ///
  /// \param address address to get the coin type of.
  TWCoinType TWAnyAddressCoin(
    ffi.Pointer<TWAnyAddress> address,
  ) {
    return TWCoinType.fromValue(_TWAnyAddressCoin(
      address,
    ));
  }

  late final _TWAnyAddressCoinPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<TWAnyAddress>)>>(
      'TWAnyAddressCoin');
  late final _TWAnyAddressCoin = _TWAnyAddressCoinPtr.asFunction<
      int Function(ffi.Pointer<TWAnyAddress>)>();

  /// Returns underlaying data (public key or key hash)
  ///
  /// \param address address to get the data of.
  ffi.Pointer<TWData> TWAnyAddressData(
    ffi.Pointer<TWAnyAddress> address,
  ) {
    return _TWAnyAddressData(
      address,
    );
  }

  late final _TWAnyAddressDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWAnyAddress>)>>('TWAnyAddressData');
  late final _TWAnyAddressData = _TWAnyAddressDataPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWAnyAddress>)>();

  /// Creates a new Account with an address, a coin type, derivation enum, derivationPath, publicKey,
  /// and extendedPublicKey. Must be deleted with TWAccountDelete after use.
  ///
  /// \param address The address of the Account.
  /// \param coin The coin type of the Account.
  /// \param derivation The derivation of the Account.
  /// \param derivationPath The derivation path of the Account.
  /// \param publicKey hex encoded public key.
  /// \param extendedPublicKey Base58 encoded extended public key.
  /// \return A new Account.
  ffi.Pointer<TWAccount> TWAccountCreate(
    ffi.Pointer<TWString> address,
    TWCoinType coin,
    TWDerivation derivation,
    ffi.Pointer<TWString> derivationPath,
    ffi.Pointer<TWString> publicKey,
    ffi.Pointer<TWString> extendedPublicKey,
  ) {
    return _TWAccountCreate(
      address,
      coin.value,
      derivation.value,
      derivationPath,
      publicKey,
      extendedPublicKey,
    );
  }

  late final _TWAccountCreatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWString>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWAccountCreate');
  late final _TWAccountCreate = _TWAccountCreatePtr.asFunction<
      ffi.Pointer<TWAccount> Function(
          ffi.Pointer<TWString>,
          int,
          int,
          ffi.Pointer<TWString>,
          ffi.Pointer<TWString>,
          ffi.Pointer<TWString>)>();

  /// Deletes an account.
  ///
  /// \param account Account to delete.
  void TWAccountDelete(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountDelete(
      account,
    );
  }

  late final _TWAccountDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWAccount>)>>(
          'TWAccountDelete');
  late final _TWAccountDelete =
      _TWAccountDeletePtr.asFunction<void Function(ffi.Pointer<TWAccount>)>();

  /// Returns the address of an account.
  ///
  /// \param account Account to get the address of.
  ffi.Pointer<TWString> TWAccountAddress(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountAddress(
      account,
    );
  }

  late final _TWAccountAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWAccount>)>>('TWAccountAddress');
  late final _TWAccountAddress = _TWAccountAddressPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWAccount>)>();

  /// Return CoinType enum of an account.
  ///
  /// \param account Account to get the coin type of.
  TWCoinType TWAccountCoin(
    ffi.Pointer<TWAccount> account,
  ) {
    return TWCoinType.fromValue(_TWAccountCoin(
      account,
    ));
  }

  late final _TWAccountCoinPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<TWAccount>)>>(
      'TWAccountCoin');
  late final _TWAccountCoin =
      _TWAccountCoinPtr.asFunction<int Function(ffi.Pointer<TWAccount>)>();

  /// Returns the derivation enum of an account.
  ///
  /// \param account Account to get the derivation enum of.
  TWDerivation TWAccountDerivation(
    ffi.Pointer<TWAccount> account,
  ) {
    return TWDerivation.fromValue(_TWAccountDerivation(
      account,
    ));
  }

  late final _TWAccountDerivationPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<TWAccount>)>>(
      'TWAccountDerivation');
  late final _TWAccountDerivation = _TWAccountDerivationPtr.asFunction<
      int Function(ffi.Pointer<TWAccount>)>();

  /// Returns derivationPath of an account.
  ///
  /// \param account Account to get the derivation path of.
  ffi.Pointer<TWString> TWAccountDerivationPath(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountDerivationPath(
      account,
    );
  }

  late final _TWAccountDerivationPathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWAccount>)>>('TWAccountDerivationPath');
  late final _TWAccountDerivationPath = _TWAccountDerivationPathPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWAccount>)>();

  /// Returns hex encoded publicKey of an account.
  ///
  /// \param account Account to get the public key of.
  ffi.Pointer<TWString> TWAccountPublicKey(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountPublicKey(
      account,
    );
  }

  late final _TWAccountPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWAccount>)>>('TWAccountPublicKey');
  late final _TWAccountPublicKey = _TWAccountPublicKeyPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWAccount>)>();

  /// Returns Base58 encoded extendedPublicKey of an account.
  ///
  /// \param account Account to get the extended public key of.
  ffi.Pointer<TWString> TWAccountExtendedPublicKey(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountExtendedPublicKey(
      account,
    );
  }

  late final _TWAccountExtendedPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWAccount>)>>('TWAccountExtendedPublicKey');
  late final _TWAccountExtendedPublicKey = _TWAccountExtendedPublicKeyPtr
      .asFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWAccount>)>();

  /// Returns stock symbol of coin
  ///
  /// \param type A coin type
  /// \return A non-null TWString stock symbol of coin
  /// \note Caller must free returned object
  ffi.Pointer<TWString> TWCoinTypeConfigurationGetSymbol(
    TWCoinType type,
  ) {
    return _TWCoinTypeConfigurationGetSymbol(
      type.value,
    );
  }

  late final _TWCoinTypeConfigurationGetSymbolPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<TWString> Function(ffi.UnsignedInt)>>(
      'TWCoinTypeConfigurationGetSymbol');
  late final _TWCoinTypeConfigurationGetSymbol =
      _TWCoinTypeConfigurationGetSymbolPtr.asFunction<
          ffi.Pointer<TWString> Function(int)>();

  /// Returns max count decimal places for minimal coin unit
  ///
  /// \param type A coin type
  /// \return Returns max count decimal places for minimal coin unit
  int TWCoinTypeConfigurationGetDecimals(
    TWCoinType type,
  ) {
    return _TWCoinTypeConfigurationGetDecimals(
      type.value,
    );
  }

  late final _TWCoinTypeConfigurationGetDecimalsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'TWCoinTypeConfigurationGetDecimals');
  late final _TWCoinTypeConfigurationGetDecimals =
      _TWCoinTypeConfigurationGetDecimalsPtr.asFunction<int Function(int)>();

  /// Returns transaction url in blockchain explorer
  ///
  /// \param type A coin type
  /// \param transactionID A transaction identifier
  /// \return Returns a non-null TWString transaction url in blockchain explorer
  ffi.Pointer<TWString> TWCoinTypeConfigurationGetTransactionURL(
    TWCoinType type,
    ffi.Pointer<TWString> transactionID,
  ) {
    return _TWCoinTypeConfigurationGetTransactionURL(
      type.value,
      transactionID,
    );
  }

  late final _TWCoinTypeConfigurationGetTransactionURLPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString> Function(
                  ffi.UnsignedInt, ffi.Pointer<TWString>)>>(
      'TWCoinTypeConfigurationGetTransactionURL');
  late final _TWCoinTypeConfigurationGetTransactionURL =
      _TWCoinTypeConfigurationGetTransactionURLPtr.asFunction<
          ffi.Pointer<TWString> Function(int, ffi.Pointer<TWString>)>();

  /// Returns account url in blockchain explorer
  ///
  /// \param type A coin type
  /// \param accountID an Account identifier
  /// \return Returns a non-null TWString account url in blockchain explorer
  ffi.Pointer<TWString> TWCoinTypeConfigurationGetAccountURL(
    TWCoinType type,
    ffi.Pointer<TWString> accountID,
  ) {
    return _TWCoinTypeConfigurationGetAccountURL(
      type.value,
      accountID,
    );
  }

  late final _TWCoinTypeConfigurationGetAccountURLPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.UnsignedInt,
              ffi.Pointer<TWString>)>>('TWCoinTypeConfigurationGetAccountURL');
  late final _TWCoinTypeConfigurationGetAccountURL =
      _TWCoinTypeConfigurationGetAccountURLPtr.asFunction<
          ffi.Pointer<TWString> Function(int, ffi.Pointer<TWString>)>();

  /// Returns full name of coin in lower case
  ///
  /// \param type A coin type
  /// \return Returns a non-null TWString, full name of coin in lower case
  ffi.Pointer<TWString> TWCoinTypeConfigurationGetID(
    TWCoinType type,
  ) {
    return _TWCoinTypeConfigurationGetID(
      type.value,
    );
  }

  late final _TWCoinTypeConfigurationGetIDPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<TWString> Function(ffi.UnsignedInt)>>(
      'TWCoinTypeConfigurationGetID');
  late final _TWCoinTypeConfigurationGetID = _TWCoinTypeConfigurationGetIDPtr
      .asFunction<ffi.Pointer<TWString> Function(int)>();

  /// Returns full name of coin
  ///
  /// \param type A coin type
  /// \return Returns a non-null TWString, full name of coin
  ffi.Pointer<TWString> TWCoinTypeConfigurationGetName(
    TWCoinType type,
  ) {
    return _TWCoinTypeConfigurationGetName(
      type.value,
    );
  }

  late final _TWCoinTypeConfigurationGetNamePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<TWString> Function(ffi.UnsignedInt)>>(
      'TWCoinTypeConfigurationGetName');
  late final _TWCoinTypeConfigurationGetName =
      _TWCoinTypeConfigurationGetNamePtr.asFunction<
          ffi.Pointer<TWString> Function(int)>();

  /// Determines whether a BIP39 English mnemonic phrase is valid.
  ///
  /// \param mnemonic Non-null BIP39 english mnemonic
  /// \return true if the mnemonic is valid, false otherwise
  bool TWMnemonicIsValid(
    ffi.Pointer<TWString> mnemonic,
  ) {
    return _TWMnemonicIsValid(
      mnemonic,
    );
  }

  late final _TWMnemonicIsValidPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWString>)>>(
          'TWMnemonicIsValid');
  late final _TWMnemonicIsValid =
      _TWMnemonicIsValidPtr.asFunction<bool Function(ffi.Pointer<TWString>)>();

  /// Determines whether word is a valid BIP39 English mnemonic word.
  ///
  /// \param word Non-null BIP39 English mnemonic word
  /// \return true if the word is a valid BIP39 English mnemonic word, false otherwise
  bool TWMnemonicIsValidWord(
    ffi.Pointer<TWString> word,
  ) {
    return _TWMnemonicIsValidWord(
      word,
    );
  }

  late final _TWMnemonicIsValidWordPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWString>)>>(
          'TWMnemonicIsValidWord');
  late final _TWMnemonicIsValidWord = _TWMnemonicIsValidWordPtr.asFunction<
      bool Function(ffi.Pointer<TWString>)>();

  /// Return BIP39 English words that match the given prefix. A single string is returned, with space-separated list of words.
  ///
  /// \param prefix Non-null string prefix
  /// \return Single non-null string, space-separated list of words containing BIP39 words that match the given prefix.
  ffi.Pointer<TWString> TWMnemonicSuggest(
    ffi.Pointer<TWString> prefix,
  ) {
    return _TWMnemonicSuggest(
      prefix,
    );
  }

  late final _TWMnemonicSuggestPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>)>>('TWMnemonicSuggest');
  late final _TWMnemonicSuggest = _TWMnemonicSuggestPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWString>)>();

  late final ffi.Pointer<ffi.Size> _TWPublicKeyCompressedSize =
      _lookup<ffi.Size>('TWPublicKeyCompressedSize');

  int get TWPublicKeyCompressedSize => _TWPublicKeyCompressedSize.value;

  late final ffi.Pointer<ffi.Size> _TWPublicKeyUncompressedSize =
      _lookup<ffi.Size>('TWPublicKeyUncompressedSize');

  int get TWPublicKeyUncompressedSize => _TWPublicKeyUncompressedSize.value;

  /// Create a public key from a block of data
  ///
  /// \param data Non-null block of data representing the public key
  /// \param type type of the public key
  /// \note Should be deleted with \TWPublicKeyDelete
  /// \return Nullable pointer to the public key
  ffi.Pointer<TWPublicKey> TWPublicKeyCreateWithData(
    ffi.Pointer<TWData1> data,
    TWPublicKeyType type,
  ) {
    return _TWPublicKeyCreateWithData(
      data,
      type.value,
    );
  }

  late final _TWPublicKeyCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWData1>,
              ffi.UnsignedInt)>>('TWPublicKeyCreateWithData');
  late final _TWPublicKeyCreateWithData =
      _TWPublicKeyCreateWithDataPtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWData1>, int)>();

  /// Delete the given public key
  ///
  /// \param pk Non-null pointer to a public key
  void TWPublicKeyDelete(
    ffi.Pointer<TWPublicKey> pk,
  ) {
    return _TWPublicKeyDelete(
      pk,
    );
  }

  late final _TWPublicKeyDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWPublicKey>)>>(
          'TWPublicKeyDelete');
  late final _TWPublicKeyDelete = _TWPublicKeyDeletePtr.asFunction<
      void Function(ffi.Pointer<TWPublicKey>)>();

  /// Determines if the given public key is valid or not
  ///
  /// \param data Non-null block of data representing the public key
  /// \param type type of the public key
  /// \return true if the block of data is a valid public key, false otherwise
  bool TWPublicKeyIsValid(
    ffi.Pointer<TWData1> data,
    TWPublicKeyType type,
  ) {
    return _TWPublicKeyIsValid(
      data,
      type.value,
    );
  }

  late final _TWPublicKeyIsValidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<TWData1>, ffi.UnsignedInt)>>('TWPublicKeyIsValid');
  late final _TWPublicKeyIsValid = _TWPublicKeyIsValidPtr.asFunction<
      bool Function(ffi.Pointer<TWData1>, int)>();

  /// Determines if the given public key is compressed or not
  ///
  /// \param pk Non-null pointer to a public key
  /// \return true if the public key is compressed, false otherwise
  bool TWPublicKeyIsCompressed(
    ffi.Pointer<TWPublicKey> pk,
  ) {
    return _TWPublicKeyIsCompressed(
      pk,
    );
  }

  late final _TWPublicKeyIsCompressedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWPublicKey>)>>(
          'TWPublicKeyIsCompressed');
  late final _TWPublicKeyIsCompressed = _TWPublicKeyIsCompressedPtr.asFunction<
      bool Function(ffi.Pointer<TWPublicKey>)>();

  /// Give the compressed public key of the given non-compressed public key
  ///
  /// \param from Non-null pointer to a non-compressed public key
  /// \return Non-null pointer to the corresponding compressed public-key
  ffi.Pointer<TWPublicKey> TWPublicKeyCompressed(
    ffi.Pointer<TWPublicKey> from,
  ) {
    return _TWPublicKeyCompressed(
      from,
    );
  }

  late final _TWPublicKeyCompressedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWPublicKey>)>>('TWPublicKeyCompressed');
  late final _TWPublicKeyCompressed = _TWPublicKeyCompressedPtr.asFunction<
      ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPublicKey>)>();

  /// Give the non-compressed public key of a corresponding compressed public key
  ///
  /// \param from Non-null pointer to the corresponding compressed public key
  /// \return Non-null pointer to the corresponding non-compressed public key
  ffi.Pointer<TWPublicKey> TWPublicKeyUncompressed(
    ffi.Pointer<TWPublicKey> from,
  ) {
    return _TWPublicKeyUncompressed(
      from,
    );
  }

  late final _TWPublicKeyUncompressedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWPublicKey>)>>('TWPublicKeyUncompressed');
  late final _TWPublicKeyUncompressed = _TWPublicKeyUncompressedPtr.asFunction<
      ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPublicKey>)>();

  /// Gives the raw data of a given public-key
  ///
  /// \param pk Non-null pointer to a public key
  /// \return Non-null pointer to the raw block of data of the given public key
  ffi.Pointer<TWData1> TWPublicKeyData(
    ffi.Pointer<TWPublicKey> pk,
  ) {
    return _TWPublicKeyData(
      pk,
    );
  }

  late final _TWPublicKeyDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWPublicKey>)>>('TWPublicKeyData');
  late final _TWPublicKeyData = _TWPublicKeyDataPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWPublicKey>)>();

  /// Verify the validity of a signature and a message using the given public key
  ///
  /// \param pk Non-null pointer to a public key
  /// \param signature Non-null pointer to a block of data corresponding to the signature
  /// \param message Non-null pointer to a block of data corresponding to the message
  /// \return true if the signature and the message belongs to the given public key, false otherwise
  bool TWPublicKeyVerify(
    ffi.Pointer<TWPublicKey> pk,
    ffi.Pointer<TWData1> signature,
    ffi.Pointer<TWData1> message,
  ) {
    return _TWPublicKeyVerify(
      pk,
      signature,
      message,
    );
  }

  late final _TWPublicKeyVerifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>)>>('TWPublicKeyVerify');
  late final _TWPublicKeyVerify = _TWPublicKeyVerifyPtr.asFunction<
      bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData1>,
          ffi.Pointer<TWData1>)>();

  /// Verify the validity as DER of a signature and a message using the given public key
  ///
  /// \param pk Non-null pointer to a public key
  /// \param signature Non-null pointer to a block of data corresponding to the signature
  /// \param message Non-null pointer to a block of data corresponding to the message
  /// \return true if the signature and the message belongs to the given public key, false otherwise
  bool TWPublicKeyVerifyAsDER(
    ffi.Pointer<TWPublicKey> pk,
    ffi.Pointer<TWData1> signature,
    ffi.Pointer<TWData1> message,
  ) {
    return _TWPublicKeyVerifyAsDER(
      pk,
      signature,
      message,
    );
  }

  late final _TWPublicKeyVerifyAsDERPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>)>>('TWPublicKeyVerifyAsDER');
  late final _TWPublicKeyVerifyAsDER = _TWPublicKeyVerifyAsDERPtr.asFunction<
      bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData1>,
          ffi.Pointer<TWData1>)>();

  /// Verify a Zilliqa schnorr signature with a signature and message.
  ///
  /// \param pk Non-null pointer to a public key
  /// \param signature Non-null pointer to a block of data corresponding to the signature
  /// \param message Non-null pointer to a block of data corresponding to the message
  /// \return true if the signature and the message belongs to the given public key, false otherwise
  bool TWPublicKeyVerifyZilliqaSchnorr(
    ffi.Pointer<TWPublicKey> pk,
    ffi.Pointer<TWData1> signature,
    ffi.Pointer<TWData1> message,
  ) {
    return _TWPublicKeyVerifyZilliqaSchnorr(
      pk,
      signature,
      message,
    );
  }

  late final _TWPublicKeyVerifyZilliqaSchnorrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>)>>('TWPublicKeyVerifyZilliqaSchnorr');
  late final _TWPublicKeyVerifyZilliqaSchnorr =
      _TWPublicKeyVerifyZilliqaSchnorrPtr.asFunction<
          bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>)>();

  /// Give the public key type (eliptic) of a given public key
  ///
  /// \param publicKey Non-null pointer to a public key
  /// \return The public key type of the given public key (eliptic)
  TWPublicKeyType TWPublicKeyKeyType(
    ffi.Pointer<TWPublicKey> publicKey,
  ) {
    return TWPublicKeyType.fromValue(_TWPublicKeyKeyType(
      publicKey,
    ));
  }

  late final _TWPublicKeyKeyTypePtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<TWPublicKey>)>>(
      'TWPublicKeyKeyType');
  late final _TWPublicKeyKeyType = _TWPublicKeyKeyTypePtr.asFunction<
      int Function(ffi.Pointer<TWPublicKey>)>();

  /// Get the public key description from a given public key
  ///
  /// \param publicKey Non-null pointer to a public key
  /// \return Non-null pointer to a string representing the description of the public key
  ffi.Pointer<TWString1> TWPublicKeyDescription(
    ffi.Pointer<TWPublicKey> publicKey,
  ) {
    return _TWPublicKeyDescription(
      publicKey,
    );
  }

  late final _TWPublicKeyDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPublicKey>)>>('TWPublicKeyDescription');
  late final _TWPublicKeyDescription = _TWPublicKeyDescriptionPtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWPublicKey>)>();

  /// Try to get a public key from a given signature and a message
  ///
  /// \param signature Non-null pointer to a block of data corresponding to the signature
  /// \param message Non-null pointer to a block of data corresponding to the message
  /// \return Null pointer if the public key can't be recover from the given signature and message,
  /// pointer to the public key otherwise
  ffi.Pointer<TWPublicKey> TWPublicKeyRecover(
    ffi.Pointer<TWData1> signature,
    ffi.Pointer<TWData1> message,
  ) {
    return _TWPublicKeyRecover(
      signature,
      message,
    );
  }

  late final _TWPublicKeyRecoverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>)>>('TWPublicKeyRecover');
  late final _TWPublicKeyRecover = _TWPublicKeyRecoverPtr.asFunction<
      ffi.Pointer<TWPublicKey> Function(
          ffi.Pointer<TWData1>, ffi.Pointer<TWData1>)>();

  /// Creates a new DerivationPath with a purpose, coin, account, change and address.
  /// Must be deleted with TWDerivationPathDelete after use.
  ///
  /// \param purpose The purpose of the Path.
  /// \param coin The coin type of the Path.
  /// \param account The derivation of the Path.
  /// \param change The derivation path of the Path.
  /// \param address hex encoded public key.
  /// \return A new DerivationPath.
  ffi.Pointer<TWDerivationPath> TWDerivationPathCreate(
    TWPurpose purpose,
    int coin,
    int account,
    int change,
    int address,
  ) {
    return _TWDerivationPathCreate(
      purpose.value,
      coin,
      account,
      change,
      address,
    );
  }

  late final _TWDerivationPathCreatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWDerivationPath> Function(ffi.UnsignedInt, ffi.Uint32,
              ffi.Uint32, ffi.Uint32, ffi.Uint32)>>('TWDerivationPathCreate');
  late final _TWDerivationPathCreate = _TWDerivationPathCreatePtr.asFunction<
      ffi.Pointer<TWDerivationPath> Function(int, int, int, int, int)>();

  /// Creates a new DerivationPath with a string
  ///
  /// \param string The string of the Path.
  /// \return A new DerivationPath or null if string is invalid.
  ffi.Pointer<TWDerivationPath> TWDerivationPathCreateWithString(
    ffi.Pointer<TWString> string,
  ) {
    return _TWDerivationPathCreateWithString(
      string,
    );
  }

  late final _TWDerivationPathCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWDerivationPath> Function(
              ffi.Pointer<TWString>)>>('TWDerivationPathCreateWithString');
  late final _TWDerivationPathCreateWithString =
      _TWDerivationPathCreateWithStringPtr.asFunction<
          ffi.Pointer<TWDerivationPath> Function(ffi.Pointer<TWString>)>();

  /// Deletes a DerivationPath.
  ///
  /// \param path DerivationPath to delete.
  void TWDerivationPathDelete(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathDelete(
      path,
    );
  }

  late final _TWDerivationPathDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathDelete');
  late final _TWDerivationPathDelete = _TWDerivationPathDeletePtr.asFunction<
      void Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the index component of a DerivationPath.
  ///
  /// \param path DerivationPath to get the index of.
  /// \param index The index component of the DerivationPath.
  /// \return DerivationPathIndex or null if index is invalid.
  ffi.Pointer<TWDerivationPathIndex> TWDerivationPathIndexAt(
    ffi.Pointer<TWDerivationPath> path,
    int index,
  ) {
    return _TWDerivationPathIndexAt(
      path,
      index,
    );
  }

  late final _TWDerivationPathIndexAtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWDerivationPathIndex> Function(
              ffi.Pointer<TWDerivationPath>,
              ffi.Uint32)>>('TWDerivationPathIndexAt');
  late final _TWDerivationPathIndexAt = _TWDerivationPathIndexAtPtr.asFunction<
      ffi.Pointer<TWDerivationPathIndex> Function(
          ffi.Pointer<TWDerivationPath>, int)>();

  /// Returns the indices count of a DerivationPath.
  ///
  /// \param path DerivationPath to get the indices count of.
  /// \return The indices count of the DerivationPath.
  int TWDerivationPathIndicesCount(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathIndicesCount(
      path,
    );
  }

  late final _TWDerivationPathIndicesCountPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathIndicesCount');
  late final _TWDerivationPathIndicesCount = _TWDerivationPathIndicesCountPtr
      .asFunction<int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the purpose enum of a DerivationPath.
  ///
  /// \param path DerivationPath to get the purpose of.
  /// \return DerivationPathPurpose.
  TWPurpose TWDerivationPathPurpose(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return TWPurpose.fromValue(_TWDerivationPathPurpose(
      path,
    ));
  }

  late final _TWDerivationPathPurposePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<TWDerivationPath>)>>('TWDerivationPathPurpose');
  late final _TWDerivationPathPurpose = _TWDerivationPathPurposePtr.asFunction<
      int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the coin value of a derivation path.
  ///
  /// \param path DerivationPath to get the coin of.
  /// \return The coin part of the DerivationPath.
  int TWDerivationPathCoin(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathCoin(
      path,
    );
  }

  late final _TWDerivationPathCoinPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathCoin');
  late final _TWDerivationPathCoin = _TWDerivationPathCoinPtr.asFunction<
      int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the account value of a derivation path.
  ///
  /// \param path DerivationPath to get the account of.
  /// \return the account part of a derivation path.
  int TWDerivationPathAccount(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathAccount(
      path,
    );
  }

  late final _TWDerivationPathAccountPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathAccount');
  late final _TWDerivationPathAccount = _TWDerivationPathAccountPtr.asFunction<
      int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the change value of a derivation path.
  ///
  /// \param path DerivationPath to get the change of.
  /// \return The change part of a derivation path.
  int TWDerivationPathChange(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathChange(
      path,
    );
  }

  late final _TWDerivationPathChangePtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathChange');
  late final _TWDerivationPathChange = _TWDerivationPathChangePtr.asFunction<
      int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the address value of a derivation path.
  ///
  /// \param path DerivationPath to get the address of.
  /// \return The address part of the derivation path.
  int TWDerivationPathAddress(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathAddress(
      path,
    );
  }

  late final _TWDerivationPathAddressPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathAddress');
  late final _TWDerivationPathAddress = _TWDerivationPathAddressPtr.asFunction<
      int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the string description of a derivation path.
  ///
  /// \param path DerivationPath to get the address of.
  /// \return The string description of the derivation path.
  ffi.Pointer<TWString> TWDerivationPathDescription(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathDescription(
      path,
    );
  }

  late final _TWDerivationPathDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWDerivationPath>)>>('TWDerivationPathDescription');
  late final _TWDerivationPathDescription =
      _TWDerivationPathDescriptionPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWDerivationPath>)>();

  late final ffi.Pointer<ffi.Size> _TWPrivateKeySize =
      _lookup<ffi.Size>('TWPrivateKeySize');

  int get TWPrivateKeySize => _TWPrivateKeySize.value;

  /// Create a random private key
  ///
  /// \note Should be deleted with \TWPrivateKeyDelete
  /// \return Non-null Private key
  ffi.Pointer<TWPrivateKey> TWPrivateKeyCreate() {
    return _TWPrivateKeyCreate();
  }

  late final _TWPrivateKeyCreatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWPrivateKey> Function()>>(
          'TWPrivateKeyCreate');
  late final _TWPrivateKeyCreate =
      _TWPrivateKeyCreatePtr.asFunction<ffi.Pointer<TWPrivateKey> Function()>();

  /// Create a private key with the given block of data
  ///
  /// \param data a block of data
  /// \note Should be deleted with \TWPrivateKeyDelete
  /// \return Nullable pointer to Private Key
  ffi.Pointer<TWPrivateKey> TWPrivateKeyCreateWithData(
    ffi.Pointer<TWData> data,
  ) {
    return _TWPrivateKeyCreateWithData(
      data,
    );
  }

  late final _TWPrivateKeyCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWData>)>>('TWPrivateKeyCreateWithData');
  late final _TWPrivateKeyCreateWithData = _TWPrivateKeyCreateWithDataPtr
      .asFunction<ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWData>)>();

  /// Deep copy a given private key
  ///
  /// \param key Non-null private key to be copied
  /// \note Should be deleted with \TWPrivateKeyDelete
  /// \return Deep copy, Nullable pointer to Private key
  ffi.Pointer<TWPrivateKey> TWPrivateKeyCreateCopy(
    ffi.Pointer<TWPrivateKey> key,
  ) {
    return _TWPrivateKeyCreateCopy(
      key,
    );
  }

  late final _TWPrivateKeyCreateCopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWPrivateKey>)>>('TWPrivateKeyCreateCopy');
  late final _TWPrivateKeyCreateCopy = _TWPrivateKeyCreateCopyPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Delete the given private key
  ///
  /// \param pk Non-null pointer to private key
  void TWPrivateKeyDelete(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyDelete(
      pk,
    );
  }

  late final _TWPrivateKeyDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWPrivateKey>)>>(
          'TWPrivateKeyDelete');
  late final _TWPrivateKeyDelete = _TWPrivateKeyDeletePtr.asFunction<
      void Function(ffi.Pointer<TWPrivateKey>)>();

  /// Determines if the given private key is valid or not.
  ///
  /// \param data block of data (private key bytes)
  /// \param curve Eliptic curve of the private key
  /// \return true if the private key is valid, false otherwise
  bool TWPrivateKeyIsValid(
    ffi.Pointer<TWData> data,
    TWCurve curve,
  ) {
    return _TWPrivateKeyIsValid(
      data,
      curve.value,
    );
  }

  late final _TWPrivateKeyIsValidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<TWData>, ffi.UnsignedInt)>>('TWPrivateKeyIsValid');
  late final _TWPrivateKeyIsValid = _TWPrivateKeyIsValidPtr.asFunction<
      bool Function(ffi.Pointer<TWData>, int)>();

  /// Convert the given private key to raw-bytes block of data
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null block of data (raw bytes) of the given private key
  ffi.Pointer<TWData> TWPrivateKeyData(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyData(
      pk,
    );
  }

  late final _TWPrivateKeyDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWPrivateKey>)>>('TWPrivateKeyData');
  late final _TWPrivateKeyData = _TWPrivateKeyDataPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Returns the public key associated with the given coinType and privateKey
  ///
  /// \param pk Non-null pointer to the private key
  /// \param coinType coinType of the given private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKey(
    ffi.Pointer<TWPrivateKey> pk,
    TWCoinType coinType,
  ) {
    return _TWPrivateKeyGetPublicKey(
      pk,
      coinType.value,
    );
  }

  late final _TWPrivateKeyGetPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>,
              ffi.UnsignedInt)>>('TWPrivateKeyGetPublicKey');
  late final _TWPrivateKeyGetPublicKey =
      _TWPrivateKeyGetPublicKeyPtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>, int)>();

  /// Returns the public key associated with the given pubkeyType and privateKey
  ///
  /// \param pk Non-null pointer to the private key
  /// \param pubkeyType pubkeyType of the given private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyByType(
    ffi.Pointer<TWPrivateKey> pk,
    TWPublicKeyType pubkeyType,
  ) {
    return _TWPrivateKeyGetPublicKeyByType(
      pk,
      pubkeyType.value,
    );
  }

  late final _TWPrivateKeyGetPublicKeyByTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>,
              ffi.UnsignedInt)>>('TWPrivateKeyGetPublicKeyByType');
  late final _TWPrivateKeyGetPublicKeyByType =
      _TWPrivateKeyGetPublicKeyByTypePtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>, int)>();

  /// Returns the Secp256k1 public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \param compressed if the given private key is compressed or not
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeySecp256k1(
    ffi.Pointer<TWPrivateKey> pk,
    bool compressed,
  ) {
    return _TWPrivateKeyGetPublicKeySecp256k1(
      pk,
      compressed,
    );
  }

  late final _TWPrivateKeyGetPublicKeySecp256k1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Bool)>>('TWPrivateKeyGetPublicKeySecp256k1');
  late final _TWPrivateKeyGetPublicKeySecp256k1 =
      _TWPrivateKeyGetPublicKeySecp256k1Ptr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>, bool)>();

  /// Returns the Nist256p1 public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyNist256p1(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyGetPublicKeyNist256p1(
      pk,
    );
  }

  late final _TWPrivateKeyGetPublicKeyNist256p1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWPrivateKey>)>>('TWPrivateKeyGetPublicKeyNist256p1');
  late final _TWPrivateKeyGetPublicKeyNist256p1 =
      _TWPrivateKeyGetPublicKeyNist256p1Ptr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Returns the Ed25519 public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyEd25519(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyGetPublicKeyEd25519(
      pk,
    );
  }

  late final _TWPrivateKeyGetPublicKeyEd25519Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWPrivateKey>)>>('TWPrivateKeyGetPublicKeyEd25519');
  late final _TWPrivateKeyGetPublicKeyEd25519 =
      _TWPrivateKeyGetPublicKeyEd25519Ptr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Returns the Ed25519Blake2b public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyEd25519Blake2b(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyGetPublicKeyEd25519Blake2b(
      pk,
    );
  }

  late final _TWPrivateKeyGetPublicKeyEd25519Blake2bPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>>(
      'TWPrivateKeyGetPublicKeyEd25519Blake2b');
  late final _TWPrivateKeyGetPublicKeyEd25519Blake2b =
      _TWPrivateKeyGetPublicKeyEd25519Blake2bPtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Returns the Ed25519Cardano public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyEd25519Cardano(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyGetPublicKeyEd25519Cardano(
      pk,
    );
  }

  late final _TWPrivateKeyGetPublicKeyEd25519CardanoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>>(
      'TWPrivateKeyGetPublicKeyEd25519Cardano');
  late final _TWPrivateKeyGetPublicKeyEd25519Cardano =
      _TWPrivateKeyGetPublicKeyEd25519CardanoPtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Returns the Curve25519 public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyCurve25519(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyGetPublicKeyCurve25519(
      pk,
    );
  }

  late final _TWPrivateKeyGetPublicKeyCurve25519Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>>(
      'TWPrivateKeyGetPublicKeyCurve25519');
  late final _TWPrivateKeyGetPublicKeyCurve25519 =
      _TWPrivateKeyGetPublicKeyCurve25519Ptr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Computes an EC Diffie-Hellman secret in constant time
  /// Supported curves: secp256k1
  ///
  /// \param pk Non-null pointer to a Private key
  /// \param publicKey Non-null pointer to the corresponding public key
  /// \param curve Eliptic curve
  /// \return The corresponding shared key as a non-null block of data
  ffi.Pointer<TWData> TWPrivateKeyGetSharedKey(
    ffi.Pointer<TWPrivateKey> pk,
    ffi.Pointer<TWPublicKey> publicKey,
    TWCurve curve,
  ) {
    return _TWPrivateKeyGetSharedKey(
      pk,
      publicKey,
      curve.value,
    );
  }

  late final _TWPrivateKeyGetSharedKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWPublicKey>,
              ffi.UnsignedInt)>>('TWPrivateKeyGetSharedKey');
  late final _TWPrivateKeyGetSharedKey =
      _TWPrivateKeyGetSharedKeyPtr.asFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWPublicKey>, int)>();

  /// Signs a digest using ECDSA and given curve.
  ///
  /// \param pk  Non-null pointer to a Private key
  /// \param digest Non-null digest block of data
  /// \param curve Eliptic curve
  /// \return Signature as a Non-null block of data
  ffi.Pointer<TWData> TWPrivateKeySign(
    ffi.Pointer<TWPrivateKey> pk,
    ffi.Pointer<TWData> digest,
    TWCurve curve,
  ) {
    return _TWPrivateKeySign(
      pk,
      digest,
      curve.value,
    );
  }

  late final _TWPrivateKeySignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWData>, ffi.UnsignedInt)>>('TWPrivateKeySign');
  late final _TWPrivateKeySign = _TWPrivateKeySignPtr.asFunction<
      ffi.Pointer<TWData> Function(
          ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWData>, int)>();

  /// Signs a digest using ECDSA. The result is encoded with DER.
  ///
  /// \param pk  Non-null pointer to a Private key
  /// \param digest Non-null digest block of data
  /// \return Signature as a Non-null block of data
  ffi.Pointer<TWData> TWPrivateKeySignAsDER(
    ffi.Pointer<TWPrivateKey> pk,
    ffi.Pointer<TWData> digest,
  ) {
    return _TWPrivateKeySignAsDER(
      pk,
      digest,
    );
  }

  late final _TWPrivateKeySignAsDERPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWData>)>>('TWPrivateKeySignAsDER');
  late final _TWPrivateKeySignAsDER = _TWPrivateKeySignAsDERPtr.asFunction<
      ffi.Pointer<TWData> Function(
          ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWData>)>();

  /// Signs a digest using ECDSA and Zilliqa schnorr signature scheme.
  ///
  /// \param pk Non-null pointer to a Private key
  /// \param message Non-null message
  /// \return Signature as a Non-null block of data
  ffi.Pointer<TWData> TWPrivateKeySignZilliqaSchnorr(
    ffi.Pointer<TWPrivateKey> pk,
    ffi.Pointer<TWData> message,
  ) {
    return _TWPrivateKeySignZilliqaSchnorr(
      pk,
      message,
    );
  }

  late final _TWPrivateKeySignZilliqaSchnorrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWData>)>>('TWPrivateKeySignZilliqaSchnorr');
  late final _TWPrivateKeySignZilliqaSchnorr =
      _TWPrivateKeySignZilliqaSchnorrPtr.asFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWData>)>();

  /// Creates a new HDWallet with a new random mnemonic with the provided strength in bits.
  ///
  /// \param strength strength in bits
  /// \param passphrase non-null passphrase
  /// \note Null is returned on invalid strength
  /// \note Returned object needs to be deleted with \TWHDWalletDelete
  /// \return Nullable TWHDWallet
  ffi.Pointer<TWHDWallet> TWHDWalletCreate(
    int strength,
    ffi.Pointer<TWString> passphrase,
  ) {
    return _TWHDWalletCreate(
      strength,
      passphrase,
    );
  }

  late final _TWHDWalletCreatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWHDWallet> Function(
              ffi.Int, ffi.Pointer<TWString>)>>('TWHDWalletCreate');
  late final _TWHDWalletCreate = _TWHDWalletCreatePtr.asFunction<
      ffi.Pointer<TWHDWallet> Function(int, ffi.Pointer<TWString>)>();

  /// Creates an HDWallet from a valid BIP39 English mnemonic and a passphrase.
  ///
  /// \param mnemonic non-null Valid BIP39 mnemonic
  /// \param passphrase  non-null passphrase
  /// \note Null is returned on invalid mnemonic
  /// \note Returned object needs to be deleted with \TWHDWalletDelete
  /// \return Nullable TWHDWallet
  ffi.Pointer<TWHDWallet> TWHDWalletCreateWithMnemonic(
    ffi.Pointer<TWString> mnemonic,
    ffi.Pointer<TWString> passphrase,
  ) {
    return _TWHDWalletCreateWithMnemonic(
      mnemonic,
      passphrase,
    );
  }

  late final _TWHDWalletCreateWithMnemonicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWHDWallet> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWHDWalletCreateWithMnemonic');
  late final _TWHDWalletCreateWithMnemonic =
      _TWHDWalletCreateWithMnemonicPtr.asFunction<
          ffi.Pointer<TWHDWallet> Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWString>)>();

  /// Creates an HDWallet from a BIP39 mnemonic, a passphrase and validation flag.
  ///
  /// \param mnemonic non-null Valid BIP39 mnemonic
  /// \param passphrase  non-null passphrase
  /// \param check validation flag
  /// \note Null is returned on invalid mnemonic
  /// \note Returned object needs to be deleted with \TWHDWalletDelete
  /// \return Nullable TWHDWallet
  ffi.Pointer<TWHDWallet> TWHDWalletCreateWithMnemonicCheck(
    ffi.Pointer<TWString> mnemonic,
    ffi.Pointer<TWString> passphrase,
    bool check,
  ) {
    return _TWHDWalletCreateWithMnemonicCheck(
      mnemonic,
      passphrase,
      check,
    );
  }

  late final _TWHDWalletCreateWithMnemonicCheckPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWHDWallet> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Bool)>>('TWHDWalletCreateWithMnemonicCheck');
  late final _TWHDWalletCreateWithMnemonicCheck =
      _TWHDWalletCreateWithMnemonicCheckPtr.asFunction<
          ffi.Pointer<TWHDWallet> Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWString>, bool)>();

  /// Creates an HDWallet from entropy (corresponding to a mnemonic).
  ///
  /// \param entropy Non-null entropy data (corresponding to a mnemonic)
  /// \param passphrase non-null passphrase
  /// \note Null is returned on invalid input
  /// \note Returned object needs to be deleted with \TWHDWalletDelete
  /// \return Nullable TWHDWallet
  ffi.Pointer<TWHDWallet> TWHDWalletCreateWithEntropy(
    ffi.Pointer<TWData> entropy,
    ffi.Pointer<TWString> passphrase,
  ) {
    return _TWHDWalletCreateWithEntropy(
      entropy,
      passphrase,
    );
  }

  late final _TWHDWalletCreateWithEntropyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWHDWallet> Function(ffi.Pointer<TWData>,
              ffi.Pointer<TWString>)>>('TWHDWalletCreateWithEntropy');
  late final _TWHDWalletCreateWithEntropy =
      _TWHDWalletCreateWithEntropyPtr.asFunction<
          ffi.Pointer<TWHDWallet> Function(
              ffi.Pointer<TWData>, ffi.Pointer<TWString>)>();

  /// Deletes a wallet.
  ///
  /// \param wallet non-null TWHDWallet
  void TWHDWalletDelete(
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWHDWalletDelete(
      wallet,
    );
  }

  late final _TWHDWalletDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWHDWallet>)>>(
          'TWHDWalletDelete');
  late final _TWHDWalletDelete =
      _TWHDWalletDeletePtr.asFunction<void Function(ffi.Pointer<TWHDWallet>)>();

  /// Wallet seed.
  ///
  /// \param wallet non-null TWHDWallet
  /// \return The wallet seed as a Non-null block of data.
  ffi.Pointer<TWData> TWHDWalletSeed(
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWHDWalletSeed(
      wallet,
    );
  }

  late final _TWHDWalletSeedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWHDWallet>)>>('TWHDWalletSeed');
  late final _TWHDWalletSeed = _TWHDWalletSeedPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWHDWallet>)>();

  /// Wallet Mnemonic
  ///
  /// \param wallet non-null TWHDWallet
  /// \return The wallet mnemonic as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletMnemonic(
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWHDWalletMnemonic(
      wallet,
    );
  }

  late final _TWHDWalletMnemonicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>)>>('TWHDWalletMnemonic');
  late final _TWHDWalletMnemonic = _TWHDWalletMnemonicPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWHDWallet>)>();

  /// Wallet entropy
  ///
  /// \param wallet non-null TWHDWallet
  /// \return The wallet entropy as a non-null block of data.
  ffi.Pointer<TWData> TWHDWalletEntropy(
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWHDWalletEntropy(
      wallet,
    );
  }

  late final _TWHDWalletEntropyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWHDWallet>)>>('TWHDWalletEntropy');
  late final _TWHDWalletEntropy = _TWHDWalletEntropyPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWHDWallet>)>();

  /// Returns master key.
  ///
  /// \param wallet non-null TWHDWallet
  /// \param curve  a curve
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return Non-null corresponding private key
  ffi.Pointer<TWPrivateKey> TWHDWalletGetMasterKey(
    ffi.Pointer<TWHDWallet> wallet,
    TWCurve curve,
  ) {
    return _TWHDWalletGetMasterKey(
      wallet,
      curve.value,
    );
  }

  late final _TWHDWalletGetMasterKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt)>>('TWHDWalletGetMasterKey');
  late final _TWHDWalletGetMasterKey = _TWHDWalletGetMasterKeyPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>, int)>();

  /// Generates the default private key for the specified coin, using default derivation.
  ///
  /// \see TWHDWalletGetKey
  /// \see TWHDWalletGetKeyDerivation
  /// \param wallet non-null TWHDWallet
  /// \param coin  a coin type
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return return the default private key for the specified coin
  ffi.Pointer<TWPrivateKey> TWHDWalletGetKeyForCoin(
    ffi.Pointer<TWHDWallet> wallet,
    TWCoinType coin,
  ) {
    return _TWHDWalletGetKeyForCoin(
      wallet,
      coin.value,
    );
  }

  late final _TWHDWalletGetKeyForCoinPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt)>>('TWHDWalletGetKeyForCoin');
  late final _TWHDWalletGetKeyForCoin = _TWHDWalletGetKeyForCoinPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>, int)>();

  /// Generates the default address for the specified coin (without exposing intermediary private key), default derivation.
  ///
  /// \see TWHDWalletGetAddressDerivation
  /// \param wallet non-null TWHDWallet
  /// \param coin  a coin type
  /// \return return the default address for the specified coin as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletGetAddressForCoin(
    ffi.Pointer<TWHDWallet> wallet,
    TWCoinType coin,
  ) {
    return _TWHDWalletGetAddressForCoin(
      wallet,
      coin.value,
    );
  }

  late final _TWHDWalletGetAddressForCoinPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt)>>('TWHDWalletGetAddressForCoin');
  late final _TWHDWalletGetAddressForCoin =
      _TWHDWalletGetAddressForCoinPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWHDWallet>, int)>();

  /// Generates the default address for the specified coin and derivation (without exposing intermediary private key).
  ///
  /// \see TWHDWalletGetAddressForCoin
  /// \param wallet non-null TWHDWallet
  /// \param coin  a coin type
  /// \param derivation  a (custom) derivation to use
  /// \return return the default address for the specified coin as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletGetAddressDerivation(
    ffi.Pointer<TWHDWallet> wallet,
    TWCoinType coin,
    TWDerivation derivation,
  ) {
    return _TWHDWalletGetAddressDerivation(
      wallet,
      coin.value,
      derivation.value,
    );
  }

  late final _TWHDWalletGetAddressDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWHDWalletGetAddressDerivation');
  late final _TWHDWalletGetAddressDerivation =
      _TWHDWalletGetAddressDerivationPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWHDWallet>, int, int)>();

  /// Generates the private key for the specified derivation path.
  ///
  /// \see TWHDWalletGetKeyForCoin
  /// \see TWHDWalletGetKeyDerivation
  /// \param wallet non-null TWHDWallet
  /// \param coin a coin type
  /// \param derivationPath  a non-null derivation path
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return The private key for the specified derivation path/coin
  ffi.Pointer<TWPrivateKey> TWHDWalletGetKey(
    ffi.Pointer<TWHDWallet> wallet,
    TWCoinType coin,
    ffi.Pointer<TWString> derivationPath,
  ) {
    return _TWHDWalletGetKey(
      wallet,
      coin.value,
      derivationPath,
    );
  }

  late final _TWHDWalletGetKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt, ffi.Pointer<TWString>)>>('TWHDWalletGetKey');
  late final _TWHDWalletGetKey = _TWHDWalletGetKeyPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(
          ffi.Pointer<TWHDWallet>, int, ffi.Pointer<TWString>)>();

  /// Generates the private key for the specified derivation.
  ///
  /// \see TWHDWalletGetKey
  /// \see TWHDWalletGetKeyForCoin
  /// \param wallet non-null TWHDWallet
  /// \param coin a coin type
  /// \param derivation a (custom) derivation to use
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return The private key for the specified derivation path/coin
  ffi.Pointer<TWPrivateKey> TWHDWalletGetKeyDerivation(
    ffi.Pointer<TWHDWallet> wallet,
    TWCoinType coin,
    TWDerivation derivation,
  ) {
    return _TWHDWalletGetKeyDerivation(
      wallet,
      coin.value,
      derivation.value,
    );
  }

  late final _TWHDWalletGetKeyDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt, ffi.UnsignedInt)>>('TWHDWalletGetKeyDerivation');
  late final _TWHDWalletGetKeyDerivation =
      _TWHDWalletGetKeyDerivationPtr.asFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWHDWallet>, int, int)>();

  /// Generates the private key for the specified derivation path and curve.
  ///
  /// \param wallet non-null TWHDWallet
  /// \param curve a curve
  /// \param derivationPath  a non-null derivation path
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return The private key for the specified derivation path/curve
  ffi.Pointer<TWPrivateKey> TWHDWalletGetKeyByCurve(
    ffi.Pointer<TWHDWallet> wallet,
    TWCurve curve,
    ffi.Pointer<TWString> derivationPath,
  ) {
    return _TWHDWalletGetKeyByCurve(
      wallet,
      curve.value,
      derivationPath,
    );
  }

  late final _TWHDWalletGetKeyByCurvePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.Pointer<TWString>)>>('TWHDWalletGetKeyByCurve');
  late final _TWHDWalletGetKeyByCurve = _TWHDWalletGetKeyByCurvePtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(
          ffi.Pointer<TWHDWallet>, int, ffi.Pointer<TWString>)>();

  /// Shortcut method to generate private key with the specified account/change/address (bip44 standard).
  ///
  /// \see https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
  ///
  /// \param wallet non-null TWHDWallet
  /// \param coin a coin type
  /// \param account valid bip44 account
  /// \param change valid bip44 change
  /// \param address valid bip44 address
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return The private key for the specified bip44 parameters
  ffi.Pointer<TWPrivateKey> TWHDWalletGetDerivedKey(
    ffi.Pointer<TWHDWallet> wallet,
    TWCoinType coin,
    int account,
    int change,
    int address,
  ) {
    return _TWHDWalletGetDerivedKey(
      wallet,
      coin.value,
      account,
      change,
      address,
    );
  }

  late final _TWHDWalletGetDerivedKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Uint32)>>('TWHDWalletGetDerivedKey');
  late final _TWHDWalletGetDerivedKey = _TWHDWalletGetDerivedKeyPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(
          ffi.Pointer<TWHDWallet>, int, int, int, int)>();

  /// Returns the extended private key (for default 0 account).
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param version hd version
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return  Extended private key as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletGetExtendedPrivateKey(
    ffi.Pointer<TWHDWallet> wallet,
    TWPurpose purpose,
    TWCoinType coin,
    TWHDVersion version,
  ) {
    return _TWHDWalletGetExtendedPrivateKey(
      wallet,
      purpose.value,
      coin.value,
      version.value,
    );
  }

  late final _TWHDWalletGetExtendedPrivateKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWHDWalletGetExtendedPrivateKey');
  late final _TWHDWalletGetExtendedPrivateKey =
      _TWHDWalletGetExtendedPrivateKeyPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>, int, int, int)>();

  /// Returns the extended public key (for default 0 account).
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param version hd version
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return  Extended public key as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletGetExtendedPublicKey(
    ffi.Pointer<TWHDWallet> wallet,
    TWPurpose purpose,
    TWCoinType coin,
    TWHDVersion version,
  ) {
    return _TWHDWalletGetExtendedPublicKey(
      wallet,
      purpose.value,
      coin.value,
      version.value,
    );
  }

  late final _TWHDWalletGetExtendedPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWHDWalletGetExtendedPublicKey');
  late final _TWHDWalletGetExtendedPublicKey =
      _TWHDWalletGetExtendedPublicKeyPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>, int, int, int)>();

  /// Returns the extended private key, for custom account.
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param derivation a derivation
  /// \param version an hd version
  /// \param account valid bip44 account
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return  Extended private key as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletGetExtendedPrivateKeyAccount(
    ffi.Pointer<TWHDWallet> wallet,
    TWPurpose purpose,
    TWCoinType coin,
    TWDerivation derivation,
    TWHDVersion version,
    int account,
  ) {
    return _TWHDWalletGetExtendedPrivateKeyAccount(
      wallet,
      purpose.value,
      coin.value,
      derivation.value,
      version.value,
      account,
    );
  }

  late final _TWHDWalletGetExtendedPrivateKeyAccountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Uint32)>>('TWHDWalletGetExtendedPrivateKeyAccount');
  late final _TWHDWalletGetExtendedPrivateKeyAccount =
      _TWHDWalletGetExtendedPrivateKeyAccountPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>, int, int, int, int, int)>();

  /// Returns the extended public key, for custom account.
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param derivation a derivation
  /// \param version an hd version
  /// \param account valid bip44 account
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return Extended public key as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletGetExtendedPublicKeyAccount(
    ffi.Pointer<TWHDWallet> wallet,
    TWPurpose purpose,
    TWCoinType coin,
    TWDerivation derivation,
    TWHDVersion version,
    int account,
  ) {
    return _TWHDWalletGetExtendedPublicKeyAccount(
      wallet,
      purpose.value,
      coin.value,
      derivation.value,
      version.value,
      account,
    );
  }

  late final _TWHDWalletGetExtendedPublicKeyAccountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Uint32)>>('TWHDWalletGetExtendedPublicKeyAccount');
  late final _TWHDWalletGetExtendedPublicKeyAccount =
      _TWHDWalletGetExtendedPublicKeyAccountPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>, int, int, int, int, int)>();

  /// Returns the extended private key (for default 0 account with derivation).
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param derivation a derivation
  /// \param version an hd version
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return  Extended private key as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletGetExtendedPrivateKeyDerivation(
    ffi.Pointer<TWHDWallet> wallet,
    TWPurpose purpose,
    TWCoinType coin,
    TWDerivation derivation,
    TWHDVersion version,
  ) {
    return _TWHDWalletGetExtendedPrivateKeyDerivation(
      wallet,
      purpose.value,
      coin.value,
      derivation.value,
      version.value,
    );
  }

  late final _TWHDWalletGetExtendedPrivateKeyDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWHDWalletGetExtendedPrivateKeyDerivation');
  late final _TWHDWalletGetExtendedPrivateKeyDerivation =
      _TWHDWalletGetExtendedPrivateKeyDerivationPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>, int, int, int, int)>();

  /// Returns the extended public key (for default 0 account with derivation).
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param derivation a derivation
  /// \param version an hd version
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return  Extended public key as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletGetExtendedPublicKeyDerivation(
    ffi.Pointer<TWHDWallet> wallet,
    TWPurpose purpose,
    TWCoinType coin,
    TWDerivation derivation,
    TWHDVersion version,
  ) {
    return _TWHDWalletGetExtendedPublicKeyDerivation(
      wallet,
      purpose.value,
      coin.value,
      derivation.value,
      version.value,
    );
  }

  late final _TWHDWalletGetExtendedPublicKeyDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWHDWalletGetExtendedPublicKeyDerivation');
  late final _TWHDWalletGetExtendedPublicKeyDerivation =
      _TWHDWalletGetExtendedPublicKeyDerivationPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>, int, int, int, int)>();

  /// Computes the public key from an extended public key representation.
  ///
  /// \param extended extended public key
  /// \param coin a coin type
  /// \param derivationPath a derivation path
  /// \note Returned object needs to be deleted with \TWPublicKeyDelete
  /// \return Nullable TWPublic key
  ffi.Pointer<TWPublicKey> TWHDWalletGetPublicKeyFromExtended(
    ffi.Pointer<TWString> extended,
    TWCoinType coin,
    ffi.Pointer<TWString> derivationPath,
  ) {
    return _TWHDWalletGetPublicKeyFromExtended(
      extended,
      coin.value,
      derivationPath,
    );
  }

  late final _TWHDWalletGetPublicKeyFromExtendedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWString>,
              ffi.UnsignedInt,
              ffi.Pointer<TWString>)>>('TWHDWalletGetPublicKeyFromExtended');
  late final _TWHDWalletGetPublicKeyFromExtended =
      _TWHDWalletGetPublicKeyFromExtendedPtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWString>, int, ffi.Pointer<TWString>)>();

  /// Loads a key from a file.
  ///
  /// \param path filepath to the key as a non-null string
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be load, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyLoad(
    ffi.Pointer<TWString> path,
  ) {
    return _TWStoredKeyLoad(
      path,
    );
  }

  late final _TWStoredKeyLoadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString>)>>('TWStoredKeyLoad');
  late final _TWStoredKeyLoad = _TWStoredKeyLoadPtr.asFunction<
      ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString>)>();

  /// Imports a private key.
  ///
  /// \param privateKey Non-null Block of data private key
  /// \param name The name of the stored key to import as a non-null string
  /// \param password Non-null block of data, password of the stored key
  /// \param coin the coin type
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportPrivateKey(
    ffi.Pointer<TWData> privateKey,
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    TWCoinType coin,
  ) {
    return _TWStoredKeyImportPrivateKey(
      privateKey,
      name,
      password,
      coin.value,
    );
  }

  late final _TWStoredKeyImportPrivateKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWData>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWData>,
              ffi.UnsignedInt)>>('TWStoredKeyImportPrivateKey');
  late final _TWStoredKeyImportPrivateKey =
      _TWStoredKeyImportPrivateKeyPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWData>,
              ffi.Pointer<TWString>, ffi.Pointer<TWData>, int)>();

  /// Imports a private key.
  ///
  /// \param privateKey Non-null Block of data private key
  /// \param name The name of the stored key to import as a non-null string
  /// \param password Non-null block of data, password of the stored key
  /// \param coin the coin type
  /// \param encryption cipher encryption mode
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportPrivateKeyWithEncryption(
    ffi.Pointer<TWData> privateKey,
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    TWCoinType coin,
    TWStoredKeyEncryption encryption,
  ) {
    return _TWStoredKeyImportPrivateKeyWithEncryption(
      privateKey,
      name,
      password,
      coin.value,
      encryption.value,
    );
  }

  late final _TWStoredKeyImportPrivateKeyWithEncryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWData>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWData>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWStoredKeyImportPrivateKeyWithEncryption');
  late final _TWStoredKeyImportPrivateKeyWithEncryption =
      _TWStoredKeyImportPrivateKeyWithEncryptionPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWData>,
              ffi.Pointer<TWString>, ffi.Pointer<TWData>, int, int)>();

  /// Imports an HD wallet.
  ///
  /// \param mnemonic Non-null bip39 mnemonic
  /// \param name The name of the stored key to import as a non-null string
  /// \param password Non-null block of data, password of the stored key
  /// \param coin the coin type
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportHDWallet(
    ffi.Pointer<TWString> mnemonic,
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    TWCoinType coin,
  ) {
    return _TWStoredKeyImportHDWallet(
      mnemonic,
      name,
      password,
      coin.value,
    );
  }

  late final _TWStoredKeyImportHDWalletPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWData>,
              ffi.UnsignedInt)>>('TWStoredKeyImportHDWallet');
  late final _TWStoredKeyImportHDWallet =
      _TWStoredKeyImportHDWalletPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWString>, ffi.Pointer<TWData>, int)>();

  /// Imports an HD wallet.
  ///
  /// \param mnemonic Non-null bip39 mnemonic
  /// \param name The name of the stored key to import as a non-null string
  /// \param password Non-null block of data, password of the stored key
  /// \param coin the coin type
  /// \param encryption cipher encryption mode
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportHDWalletWithEncryption(
    ffi.Pointer<TWString> mnemonic,
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    TWCoinType coin,
    TWStoredKeyEncryption encryption,
  ) {
    return _TWStoredKeyImportHDWalletWithEncryption(
      mnemonic,
      name,
      password,
      coin.value,
      encryption.value,
    );
  }

  late final _TWStoredKeyImportHDWalletWithEncryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWData>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWStoredKeyImportHDWalletWithEncryption');
  late final _TWStoredKeyImportHDWalletWithEncryption =
      _TWStoredKeyImportHDWalletWithEncryptionPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWString>, ffi.Pointer<TWData>, int, int)>();

  /// Imports a key from JSON.
  ///
  /// \param json Json stored key import format as a non-null block of data
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportJSON(
    ffi.Pointer<TWData> json,
  ) {
    return _TWStoredKeyImportJSON(
      json,
    );
  }

  late final _TWStoredKeyImportJSONPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWData>)>>('TWStoredKeyImportJSON');
  late final _TWStoredKeyImportJSON = _TWStoredKeyImportJSONPtr.asFunction<
      ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWData>)>();

  /// Creates a new key, with given encryption strength level. Returned object needs to be deleted.
  ///
  /// \param name The name of the key to be stored
  /// \param password Non-null block of data, password of the stored key
  /// \param encryptionLevel The level of encryption, see \TWStoredKeyEncryptionLevel
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return The stored key as a non-null pointer
  ffi.Pointer<TWStoredKey> TWStoredKeyCreateLevel(
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    TWStoredKeyEncryptionLevel encryptionLevel,
  ) {
    return _TWStoredKeyCreateLevel(
      name,
      password,
      encryptionLevel.value,
    );
  }

  late final _TWStoredKeyCreateLevelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWData>, ffi.UnsignedInt)>>('TWStoredKeyCreateLevel');
  late final _TWStoredKeyCreateLevel = _TWStoredKeyCreateLevelPtr.asFunction<
      ffi.Pointer<TWStoredKey> Function(
          ffi.Pointer<TWString>, ffi.Pointer<TWData>, int)>();

  /// Creates a new key, with given encryption strength level.  Returned object needs to be deleted.
  ///
  /// \param name The name of the key to be stored
  /// \param password Non-null block of data, password of the stored key
  /// \param encryptionLevel The level of encryption, see \TWStoredKeyEncryptionLevel
  /// \param encryption cipher encryption mode
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return The stored key as a non-null pointer
  ffi.Pointer<TWStoredKey> TWStoredKeyCreateLevelAndEncryption(
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    TWStoredKeyEncryptionLevel encryptionLevel,
    TWStoredKeyEncryption encryption,
  ) {
    return _TWStoredKeyCreateLevelAndEncryption(
      name,
      password,
      encryptionLevel.value,
      encryption.value,
    );
  }

  late final _TWStoredKeyCreateLevelAndEncryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWData>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWStoredKeyCreateLevelAndEncryption');
  late final _TWStoredKeyCreateLevelAndEncryption =
      _TWStoredKeyCreateLevelAndEncryptionPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWData>, int, int)>();

  /// Creates a new key.
  ///
  /// \deprecated use TWStoredKeyCreateLevel.
  /// \param name The name of the key to be stored
  /// \param password Non-null block of data, password of the stored key
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return The stored key as a non-null pointer
  ffi.Pointer<TWStoredKey> TWStoredKeyCreate(
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
  ) {
    return _TWStoredKeyCreate(
      name,
      password,
    );
  }

  late final _TWStoredKeyCreatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWData>)>>('TWStoredKeyCreate');
  late final _TWStoredKeyCreate = _TWStoredKeyCreatePtr.asFunction<
      ffi.Pointer<TWStoredKey> Function(
          ffi.Pointer<TWString>, ffi.Pointer<TWData>)>();

  /// Creates a new key.
  ///
  /// \deprecated use TWStoredKeyCreateLevel.
  /// \param name The name of the key to be stored
  /// \param password Non-null block of data, password of the stored key
  /// \param encryption cipher encryption mode
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return The stored key as a non-null pointer
  ffi.Pointer<TWStoredKey> TWStoredKeyCreateEncryption(
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    TWStoredKeyEncryption encryption,
  ) {
    return _TWStoredKeyCreateEncryption(
      name,
      password,
      encryption.value,
    );
  }

  late final _TWStoredKeyCreateEncryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWData>,
              ffi.UnsignedInt)>>('TWStoredKeyCreateEncryption');
  late final _TWStoredKeyCreateEncryption =
      _TWStoredKeyCreateEncryptionPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWData>, int)>();

  /// Delete a stored key
  ///
  /// \param key The key to be deleted
  void TWStoredKeyDelete(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyDelete(
      key,
    );
  }

  late final _TWStoredKeyDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWStoredKey>)>>(
          'TWStoredKeyDelete');
  late final _TWStoredKeyDelete = _TWStoredKeyDeletePtr.asFunction<
      void Function(ffi.Pointer<TWStoredKey>)>();

  /// Stored key unique identifier.
  ///
  /// \param key Non-null pointer to a stored key
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return The stored key unique identifier if it's found, null pointer otherwise.
  ffi.Pointer<TWString> TWStoredKeyIdentifier(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyIdentifier(
      key,
    );
  }

  late final _TWStoredKeyIdentifierPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWStoredKey>)>>('TWStoredKeyIdentifier');
  late final _TWStoredKeyIdentifier = _TWStoredKeyIdentifierPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWStoredKey>)>();

  /// Stored key namer.
  ///
  /// \param key Non-null pointer to a stored key
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return The stored key name as a non-null string pointer.
  ffi.Pointer<TWString> TWStoredKeyName(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyName(
      key,
    );
  }

  late final _TWStoredKeyNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWStoredKey>)>>('TWStoredKeyName');
  late final _TWStoredKeyName = _TWStoredKeyNamePtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWStoredKey>)>();

  /// Whether this key is a mnemonic phrase for a HD wallet.
  ///
  /// \param key Non-null pointer to a stored key
  /// \return true if the given stored key is a mnemonic, false otherwise
  bool TWStoredKeyIsMnemonic(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyIsMnemonic(
      key,
    );
  }

  late final _TWStoredKeyIsMnemonicPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWStoredKey>)>>(
          'TWStoredKeyIsMnemonic');
  late final _TWStoredKeyIsMnemonic = _TWStoredKeyIsMnemonicPtr.asFunction<
      bool Function(ffi.Pointer<TWStoredKey>)>();

  /// The number of accounts.
  ///
  /// \param key Non-null pointer to a stored key
  /// \return the number of accounts associated to the given stored key
  int TWStoredKeyAccountCount(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyAccountCount(
      key,
    );
  }

  late final _TWStoredKeyAccountCountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<TWStoredKey>)>>(
          'TWStoredKeyAccountCount');
  late final _TWStoredKeyAccountCount = _TWStoredKeyAccountCountPtr.asFunction<
      int Function(ffi.Pointer<TWStoredKey>)>();

  /// Returns the account at a given index.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param index the account index to be retrieved
  /// \note Returned object needs to be deleted with \TWAccountDelete
  /// \return Null pointer if the associated account is not found, pointer to the account otherwise.
  ffi.Pointer<TWAccount> TWStoredKeyAccount(
    ffi.Pointer<TWStoredKey> key,
    int index,
  ) {
    return _TWStoredKeyAccount(
      key,
      index,
    );
  }

  late final _TWStoredKeyAccountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWStoredKey>, ffi.Size)>>('TWStoredKeyAccount');
  late final _TWStoredKeyAccount = _TWStoredKeyAccountPtr.asFunction<
      ffi.Pointer<TWAccount> Function(ffi.Pointer<TWStoredKey>, int)>();

  /// Returns the account for a specific coin, creating it if necessary.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin The coin type
  /// \param wallet The associated HD wallet, can be null.
  /// \note Returned object needs to be deleted with \TWAccountDelete
  /// \return Null pointer if the associated account is not found/not created, pointer to the account otherwise.
  ffi.Pointer<TWAccount> TWStoredKeyAccountForCoin(
    ffi.Pointer<TWStoredKey> key,
    TWCoinType coin,
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWStoredKeyAccountForCoin(
      key,
      coin.value,
      wallet,
    );
  }

  late final _TWStoredKeyAccountForCoinPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWStoredKey>,
              ffi.UnsignedInt,
              ffi.Pointer<TWHDWallet>)>>('TWStoredKeyAccountForCoin');
  late final _TWStoredKeyAccountForCoin =
      _TWStoredKeyAccountForCoinPtr.asFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWStoredKey>, int, ffi.Pointer<TWHDWallet>)>();

  /// Returns the account for a specific coin + derivation, creating it if necessary.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin The coin type
  /// \param derivation The derivation for the given coin
  /// \param wallet the associated HD wallet, can be null.
  /// \note Returned object needs to be deleted with \TWAccountDelete
  /// \return Null pointer if the associated account is not found/not created, pointer to the account otherwise.
  ffi.Pointer<TWAccount> TWStoredKeyAccountForCoinDerivation(
    ffi.Pointer<TWStoredKey> key,
    TWCoinType coin,
    TWDerivation derivation,
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWStoredKeyAccountForCoinDerivation(
      key,
      coin.value,
      derivation.value,
      wallet,
    );
  }

  late final _TWStoredKeyAccountForCoinDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWStoredKey>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<TWHDWallet>)>>('TWStoredKeyAccountForCoinDerivation');
  late final _TWStoredKeyAccountForCoinDerivation =
      _TWStoredKeyAccountForCoinDerivationPtr.asFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWStoredKey>, int, int, ffi.Pointer<TWHDWallet>)>();

  /// Adds a new account, using given derivation (usually TWDerivationDefault)
  /// and derivation path (usually matches path from derivation, but custom possible).
  ///
  /// \param key Non-null pointer to a stored key
  /// \param address Non-null pointer to the address of the coin for this account
  /// \param coin coin type
  /// \param derivation derivation of the given coin type
  /// \param derivationPath HD bip44 derivation path of the given coin
  /// \param publicKey Non-null public key of the given coin/address
  /// \param extendedPublicKey Non-null extended public key of the given coin/address
  void TWStoredKeyAddAccountDerivation(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWString> address,
    TWCoinType coin,
    TWDerivation derivation,
    ffi.Pointer<TWString> derivationPath,
    ffi.Pointer<TWString> publicKey,
    ffi.Pointer<TWString> extendedPublicKey,
  ) {
    return _TWStoredKeyAddAccountDerivation(
      key,
      address,
      coin.value,
      derivation.value,
      derivationPath,
      publicKey,
      extendedPublicKey,
    );
  }

  late final _TWStoredKeyAddAccountDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWString>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWStoredKeyAddAccountDerivation');
  late final _TWStoredKeyAddAccountDerivation =
      _TWStoredKeyAddAccountDerivationPtr.asFunction<
          void Function(
              ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWString>,
              int,
              int,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>();

  /// Adds a new account, using given derivation path.
  ///
  /// \deprecated Use TWStoredKeyAddAccountDerivation (with TWDerivationDefault) instead.
  /// \param key Non-null pointer to a stored key
  /// \param address Non-null pointer to the address of the coin for this account
  /// \param coin coin type
  /// \param derivationPath HD bip44 derivation path of the given coin
  /// \param publicKey Non-null public key of the given coin/address
  /// \param extendedPublicKey Non-null extended public key of the given coin/address
  void TWStoredKeyAddAccount(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWString> address,
    TWCoinType coin,
    ffi.Pointer<TWString> derivationPath,
    ffi.Pointer<TWString> publicKey,
    ffi.Pointer<TWString> extendedPublicKey,
  ) {
    return _TWStoredKeyAddAccount(
      key,
      address,
      coin.value,
      derivationPath,
      publicKey,
      extendedPublicKey,
    );
  }

  late final _TWStoredKeyAddAccountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWString>,
              ffi.UnsignedInt,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWStoredKeyAddAccount');
  late final _TWStoredKeyAddAccount = _TWStoredKeyAddAccountPtr.asFunction<
      void Function(
          ffi.Pointer<TWStoredKey>,
          ffi.Pointer<TWString>,
          int,
          ffi.Pointer<TWString>,
          ffi.Pointer<TWString>,
          ffi.Pointer<TWString>)>();

  /// Remove the account for a specific coin
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin Account coin type to be removed
  void TWStoredKeyRemoveAccountForCoin(
    ffi.Pointer<TWStoredKey> key,
    TWCoinType coin,
  ) {
    return _TWStoredKeyRemoveAccountForCoin(
      key,
      coin.value,
    );
  }

  late final _TWStoredKeyRemoveAccountForCoinPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWStoredKey>,
              ffi.UnsignedInt)>>('TWStoredKeyRemoveAccountForCoin');
  late final _TWStoredKeyRemoveAccountForCoin =
      _TWStoredKeyRemoveAccountForCoinPtr.asFunction<
          void Function(ffi.Pointer<TWStoredKey>, int)>();

  /// Remove the account for a specific coin with the given derivation.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin Account coin type to be removed
  /// \param derivation The derivation of the given coin type
  void TWStoredKeyRemoveAccountForCoinDerivation(
    ffi.Pointer<TWStoredKey> key,
    TWCoinType coin,
    TWDerivation derivation,
  ) {
    return _TWStoredKeyRemoveAccountForCoinDerivation(
      key,
      coin.value,
      derivation.value,
    );
  }

  late final _TWStoredKeyRemoveAccountForCoinDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWStoredKey>, ffi.UnsignedInt,
              ffi.UnsignedInt)>>('TWStoredKeyRemoveAccountForCoinDerivation');
  late final _TWStoredKeyRemoveAccountForCoinDerivation =
      _TWStoredKeyRemoveAccountForCoinDerivationPtr.asFunction<
          void Function(ffi.Pointer<TWStoredKey>, int, int)>();

  /// Remove the account for a specific coin with the given derivation path.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin Account coin type to be removed
  /// \param derivationPath The derivation path (bip44) of the given coin type
  void TWStoredKeyRemoveAccountForCoinDerivationPath(
    ffi.Pointer<TWStoredKey> key,
    TWCoinType coin,
    ffi.Pointer<TWString> derivationPath,
  ) {
    return _TWStoredKeyRemoveAccountForCoinDerivationPath(
      key,
      coin.value,
      derivationPath,
    );
  }

  late final _TWStoredKeyRemoveAccountForCoinDerivationPathPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<TWStoredKey>, ffi.UnsignedInt,
                  ffi.Pointer<TWString>)>>(
      'TWStoredKeyRemoveAccountForCoinDerivationPath');
  late final _TWStoredKeyRemoveAccountForCoinDerivationPath =
      _TWStoredKeyRemoveAccountForCoinDerivationPathPtr.asFunction<
          void Function(
              ffi.Pointer<TWStoredKey>, int, ffi.Pointer<TWString>)>();

  /// Saves the key to a file.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param path Non-null string filepath where the key will be saved
  /// \return true if the key was successfully stored in the given filepath file, false otherwise
  bool TWStoredKeyStore(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWString> path,
  ) {
    return _TWStoredKeyStore(
      key,
      path,
    );
  }

  late final _TWStoredKeyStorePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWString>)>>('TWStoredKeyStore');
  late final _TWStoredKeyStore = _TWStoredKeyStorePtr.asFunction<
      bool Function(ffi.Pointer<TWStoredKey>, ffi.Pointer<TWString>)>();

  /// Decrypts the private key.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param password Non-null block of data, password of the stored key
  /// \return Decrypted private key as a block of data if success, null pointer otherwise
  ffi.Pointer<TWData> TWStoredKeyDecryptPrivateKey(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWData> password,
  ) {
    return _TWStoredKeyDecryptPrivateKey(
      key,
      password,
    );
  }

  late final _TWStoredKeyDecryptPrivateKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWData>)>>('TWStoredKeyDecryptPrivateKey');
  late final _TWStoredKeyDecryptPrivateKey =
      _TWStoredKeyDecryptPrivateKeyPtr.asFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWStoredKey>, ffi.Pointer<TWData>)>();

  /// Decrypts the mnemonic phrase.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param password Non-null block of data, password of the stored key
  /// \return Bip39 decrypted mnemonic if success, null pointer otherwise
  ffi.Pointer<TWString> TWStoredKeyDecryptMnemonic(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWData> password,
  ) {
    return _TWStoredKeyDecryptMnemonic(
      key,
      password,
    );
  }

  late final _TWStoredKeyDecryptMnemonicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWData>)>>('TWStoredKeyDecryptMnemonic');
  late final _TWStoredKeyDecryptMnemonic =
      _TWStoredKeyDecryptMnemonicPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWStoredKey>, ffi.Pointer<TWData>)>();

  /// Returns the private key for a specific coin.  Returned object needs to be deleted.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin Account coin type to be queried
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return Null pointer on failure, pointer to the private key otherwise
  ffi.Pointer<TWPrivateKey> TWStoredKeyPrivateKey(
    ffi.Pointer<TWStoredKey> key,
    TWCoinType coin,
    ffi.Pointer<TWData> password,
  ) {
    return _TWStoredKeyPrivateKey(
      key,
      coin.value,
      password,
    );
  }

  late final _TWStoredKeyPrivateKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWStoredKey>,
              ffi.UnsignedInt, ffi.Pointer<TWData>)>>('TWStoredKeyPrivateKey');
  late final _TWStoredKeyPrivateKey = _TWStoredKeyPrivateKeyPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(
          ffi.Pointer<TWStoredKey>, int, ffi.Pointer<TWData>)>();

  /// Decrypts and returns the HD Wallet for mnemonic phrase keys.  Returned object needs to be deleted.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param password Non-null block of data, password of the stored key
  /// \note Returned object needs to be deleted with \TWHDWalletDelete
  /// \return Null pointer on failure, pointer to the HDWallet otherwise
  ffi.Pointer<TWHDWallet> TWStoredKeyWallet(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWData> password,
  ) {
    return _TWStoredKeyWallet(
      key,
      password,
    );
  }

  late final _TWStoredKeyWalletPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWHDWallet> Function(ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWData>)>>('TWStoredKeyWallet');
  late final _TWStoredKeyWallet = _TWStoredKeyWalletPtr.asFunction<
      ffi.Pointer<TWHDWallet> Function(
          ffi.Pointer<TWStoredKey>, ffi.Pointer<TWData>)>();

  /// Exports the key as JSON
  ///
  /// \param key Non-null pointer to a stored key
  /// \return Null pointer on failure, pointer to a block of data containing the json otherwise
  ffi.Pointer<TWData> TWStoredKeyExportJSON(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyExportJSON(
      key,
    );
  }

  late final _TWStoredKeyExportJSONPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWStoredKey>)>>('TWStoredKeyExportJSON');
  late final _TWStoredKeyExportJSON = _TWStoredKeyExportJSONPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWStoredKey>)>();

  /// Fills in empty and invalid addresses.
  /// This method needs the encryption password to re-derive addresses from private keys.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param password Non-null block of data, password of the stored key
  /// \return `false` if the password is incorrect, true otherwise.
  bool TWStoredKeyFixAddresses(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWData> password,
  ) {
    return _TWStoredKeyFixAddresses(
      key,
      password,
    );
  }

  late final _TWStoredKeyFixAddressesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWData>)>>('TWStoredKeyFixAddresses');
  late final _TWStoredKeyFixAddresses = _TWStoredKeyFixAddressesPtr.asFunction<
      bool Function(ffi.Pointer<TWStoredKey>, ffi.Pointer<TWData>)>();

  /// Retrieve stored key encoding parameters, as JSON string.
  ///
  /// \param key Non-null pointer to a stored key
  /// \return Null pointer on failure, encoding parameter as a json string otherwise.
  ffi.Pointer<TWString> TWStoredKeyEncryptionParameters(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyEncryptionParameters(
      key,
    );
  }

  late final _TWStoredKeyEncryptionParametersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWStoredKey>)>>('TWStoredKeyEncryptionParameters');
  late final _TWStoredKeyEncryptionParameters =
      _TWStoredKeyEncryptionParametersPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWStoredKey>)>();
}

typedef ptrdiff_t = ffi.Long;
typedef Dartptrdiff_t = int;

final class max_align_t extends ffi.Opaque {}

typedef __u_char = ffi.UnsignedChar;
typedef Dart__u_char = int;
typedef __u_short = ffi.UnsignedShort;
typedef Dart__u_short = int;
typedef __u_int = ffi.UnsignedInt;
typedef Dart__u_int = int;
typedef __u_long = ffi.UnsignedLong;
typedef Dart__u_long = int;
typedef __int8_t = ffi.SignedChar;
typedef Dart__int8_t = int;
typedef __uint8_t = ffi.UnsignedChar;
typedef Dart__uint8_t = int;
typedef __int16_t = ffi.Short;
typedef Dart__int16_t = int;
typedef __uint16_t = ffi.UnsignedShort;
typedef Dart__uint16_t = int;
typedef __int32_t = ffi.Int;
typedef Dart__int32_t = int;
typedef __uint32_t = ffi.UnsignedInt;
typedef Dart__uint32_t = int;
typedef __int64_t = ffi.Long;
typedef Dart__int64_t = int;
typedef __uint64_t = ffi.UnsignedLong;
typedef Dart__uint64_t = int;
typedef __int_least8_t = __int8_t;
typedef __uint_least8_t = __uint8_t;
typedef __int_least16_t = __int16_t;
typedef __uint_least16_t = __uint16_t;
typedef __int_least32_t = __int32_t;
typedef __uint_least32_t = __uint32_t;
typedef __int_least64_t = __int64_t;
typedef __uint_least64_t = __uint64_t;
typedef __quad_t = ffi.Long;
typedef Dart__quad_t = int;
typedef __u_quad_t = ffi.UnsignedLong;
typedef Dart__u_quad_t = int;
typedef __intmax_t = ffi.Long;
typedef Dart__intmax_t = int;
typedef __uintmax_t = ffi.UnsignedLong;
typedef Dart__uintmax_t = int;
typedef __dev_t = ffi.UnsignedLong;
typedef Dart__dev_t = int;
typedef __uid_t = ffi.UnsignedInt;
typedef Dart__uid_t = int;
typedef __gid_t = ffi.UnsignedInt;
typedef Dart__gid_t = int;
typedef __ino_t = ffi.UnsignedLong;
typedef Dart__ino_t = int;
typedef __ino64_t = ffi.UnsignedLong;
typedef Dart__ino64_t = int;
typedef __mode_t = ffi.UnsignedInt;
typedef Dart__mode_t = int;
typedef __nlink_t = ffi.UnsignedLong;
typedef Dart__nlink_t = int;
typedef __off_t = ffi.Long;
typedef Dart__off_t = int;
typedef __off64_t = ffi.Long;
typedef Dart__off64_t = int;
typedef __pid_t = ffi.Int;
typedef Dart__pid_t = int;

final class __fsid_t extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> __val;
}

typedef __clock_t = ffi.Long;
typedef Dart__clock_t = int;
typedef __rlim_t = ffi.UnsignedLong;
typedef Dart__rlim_t = int;
typedef __rlim64_t = ffi.UnsignedLong;
typedef Dart__rlim64_t = int;
typedef __id_t = ffi.UnsignedInt;
typedef Dart__id_t = int;
typedef __time_t = ffi.Long;
typedef Dart__time_t = int;
typedef __useconds_t = ffi.UnsignedInt;
typedef Dart__useconds_t = int;
typedef __suseconds_t = ffi.Long;
typedef Dart__suseconds_t = int;
typedef __suseconds64_t = ffi.Long;
typedef Dart__suseconds64_t = int;
typedef __daddr_t = ffi.Int;
typedef Dart__daddr_t = int;
typedef __key_t = ffi.Int;
typedef Dart__key_t = int;
typedef __clockid_t = ffi.Int;
typedef Dart__clockid_t = int;
typedef __timer_t = ffi.Pointer<ffi.Void>;
typedef __blksize_t = ffi.Long;
typedef Dart__blksize_t = int;
typedef __blkcnt_t = ffi.Long;
typedef Dart__blkcnt_t = int;
typedef __blkcnt64_t = ffi.Long;
typedef Dart__blkcnt64_t = int;
typedef __fsblkcnt_t = ffi.UnsignedLong;
typedef Dart__fsblkcnt_t = int;
typedef __fsblkcnt64_t = ffi.UnsignedLong;
typedef Dart__fsblkcnt64_t = int;
typedef __fsfilcnt_t = ffi.UnsignedLong;
typedef Dart__fsfilcnt_t = int;
typedef __fsfilcnt64_t = ffi.UnsignedLong;
typedef Dart__fsfilcnt64_t = int;
typedef __fsword_t = ffi.Long;
typedef Dart__fsword_t = int;
typedef __ssize_t = ffi.Long;
typedef Dart__ssize_t = int;
typedef __syscall_slong_t = ffi.Long;
typedef Dart__syscall_slong_t = int;
typedef __syscall_ulong_t = ffi.UnsignedLong;
typedef Dart__syscall_ulong_t = int;
typedef __loff_t = __off64_t;
typedef __caddr_t = ffi.Pointer<ffi.Char>;
typedef __intptr_t = ffi.Long;
typedef Dart__intptr_t = int;
typedef __socklen_t = ffi.UnsignedInt;
typedef Dart__socklen_t = int;
typedef __sig_atomic_t = ffi.Int;
typedef Dart__sig_atomic_t = int;
typedef int_least8_t = __int_least8_t;
typedef int_least16_t = __int_least16_t;
typedef int_least32_t = __int_least32_t;
typedef int_least64_t = __int_least64_t;
typedef uint_least8_t = __uint_least8_t;
typedef uint_least16_t = __uint_least16_t;
typedef uint_least32_t = __uint_least32_t;
typedef uint_least64_t = __uint_least64_t;
typedef int_fast8_t = ffi.SignedChar;
typedef Dartint_fast8_t = int;
typedef int_fast16_t = ffi.Long;
typedef Dartint_fast16_t = int;
typedef int_fast32_t = ffi.Long;
typedef Dartint_fast32_t = int;
typedef int_fast64_t = ffi.Long;
typedef Dartint_fast64_t = int;
typedef uint_fast8_t = ffi.UnsignedChar;
typedef Dartuint_fast8_t = int;
typedef uint_fast16_t = ffi.UnsignedLong;
typedef Dartuint_fast16_t = int;
typedef uint_fast32_t = ffi.UnsignedLong;
typedef Dartuint_fast32_t = int;
typedef uint_fast64_t = ffi.UnsignedLong;
typedef Dartuint_fast64_t = int;
typedef intmax_t = __intmax_t;
typedef uintmax_t = __uintmax_t;
typedef _Float32 = ffi.Float;
typedef Dart_Float32 = double;
typedef _Float64 = ffi.Double;
typedef Dart_Float64 = double;
typedef _Float32x = ffi.Double;
typedef Dart_Float32x = double;

final class div_t extends ffi.Struct {
  @ffi.Int()
  external int quot;

  @ffi.Int()
  external int rem;
}

final class ldiv_t extends ffi.Struct {
  @ffi.Long()
  external int quot;

  @ffi.Long()
  external int rem;
}

final class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

typedef u_char = __u_char;
typedef u_short = __u_short;
typedef u_int = __u_int;
typedef u_long = __u_long;
typedef quad_t = __quad_t;
typedef u_quad_t = __u_quad_t;
typedef fsid_t = __fsid_t;
typedef loff_t = __loff_t;
typedef ino_t = __ino_t;
typedef dev_t = __dev_t;
typedef gid_t = __gid_t;
typedef mode_t = __mode_t;
typedef nlink_t = __nlink_t;
typedef uid_t = __uid_t;
typedef off_t = __off_t;
typedef pid_t = __pid_t;
typedef id_t = __id_t;
typedef ssize_t = __ssize_t;
typedef daddr_t = __daddr_t;
typedef caddr_t = __caddr_t;
typedef key_t = __key_t;
typedef clock_t = __clock_t;
typedef clockid_t = __clockid_t;
typedef time_t = __time_t;
typedef timer_t = __timer_t;
typedef ulong = ffi.UnsignedLong;
typedef Dartulong = int;
typedef ushort = ffi.UnsignedShort;
typedef Dartushort = int;
typedef uint = ffi.UnsignedInt;
typedef Dartuint = int;
typedef u_int8_t = __uint8_t;
typedef u_int16_t = __uint16_t;
typedef u_int32_t = __uint32_t;
typedef u_int64_t = __uint64_t;
typedef register_t = ffi.Long;
typedef Dartregister_t = int;

final class __sigset_t extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedLong> __val;
}

typedef sigset_t = __sigset_t;

final class timeval extends ffi.Struct {
  @__time_t()
  external int tv_sec;

  @__suseconds_t()
  external int tv_usec;
}

final class timespec extends ffi.Struct {
  @__time_t()
  external int tv_sec;

  @__syscall_slong_t()
  external int tv_nsec;
}

typedef suseconds_t = __suseconds_t;
typedef __fd_mask = ffi.Long;
typedef Dart__fd_mask = int;

final class fd_set extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__fd_mask> __fds_bits;
}

typedef fd_mask = __fd_mask;
typedef blksize_t = __blksize_t;
typedef blkcnt_t = __blkcnt_t;
typedef fsblkcnt_t = __fsblkcnt_t;
typedef fsfilcnt_t = __fsfilcnt_t;

final class UnnamedStruct1 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int __low;

  @ffi.UnsignedInt()
  external int __high;
}

final class __atomic_wide_counter extends ffi.Union {
  @ffi.UnsignedLongLong()
  external int __value64;

  external UnnamedStruct1 __value32;
}

final class __pthread_internal_list extends ffi.Struct {
  external ffi.Pointer<__pthread_internal_list> __prev;

  external ffi.Pointer<__pthread_internal_list> __next;
}

typedef __pthread_list_t = __pthread_internal_list;

final class __pthread_internal_slist extends ffi.Struct {
  external ffi.Pointer<__pthread_internal_slist> __next;
}

typedef __pthread_slist_t = __pthread_internal_slist;

final class __pthread_mutex_s extends ffi.Struct {
  @ffi.Int()
  external int __lock;

  @ffi.UnsignedInt()
  external int __count;

  @ffi.Int()
  external int __owner;

  @ffi.UnsignedInt()
  external int __nusers;

  @ffi.Int()
  external int __kind;

  @ffi.Short()
  external int __spins;

  @ffi.Short()
  external int __elision;

  external __pthread_list_t __list;
}

final class __pthread_rwlock_arch_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int __readers;

  @ffi.UnsignedInt()
  external int __writers;

  @ffi.UnsignedInt()
  external int __wrphase_futex;

  @ffi.UnsignedInt()
  external int __writers_futex;

  @ffi.UnsignedInt()
  external int __pad3;

  @ffi.UnsignedInt()
  external int __pad4;

  @ffi.Int()
  external int __cur_writer;

  @ffi.Int()
  external int __shared;

  @ffi.SignedChar()
  external int __rwelision;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedChar> __pad1;

  @ffi.UnsignedLong()
  external int __pad2;

  @ffi.UnsignedInt()
  external int __flags;
}

final class __pthread_cond_s extends ffi.Struct {
  external __atomic_wide_counter __wseq;

  external __atomic_wide_counter __g1_start;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_refs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_size;

  @ffi.UnsignedInt()
  external int __g1_orig_size;

  @ffi.UnsignedInt()
  external int __wrefs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_signals;
}

typedef __tss_t = ffi.UnsignedInt;
typedef Dart__tss_t = int;
typedef __thrd_t = ffi.UnsignedLong;
typedef Dart__thrd_t = int;

final class __once_flag extends ffi.Struct {
  @ffi.Int()
  external int __data;
}

typedef pthread_t = ffi.UnsignedLong;
typedef Dartpthread_t = int;

final class pthread_mutexattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

final class pthread_condattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

typedef pthread_key_t = ffi.UnsignedInt;
typedef Dartpthread_key_t = int;
typedef pthread_once_t = ffi.Int;
typedef Dartpthread_once_t = int;

final class pthread_attr_t extends ffi.Union {
  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_mutex_t extends ffi.Union {
  external __pthread_mutex_s __data;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_cond_t extends ffi.Union {
  external __pthread_cond_s __data;

  @ffi.Array.multi([48])
  external ffi.Array<ffi.Char> __size;

  @ffi.LongLong()
  external int __align;
}

final class pthread_rwlock_t extends ffi.Union {
  external __pthread_rwlock_arch_t __data;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_rwlockattr_t extends ffi.Union {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_barrier_t extends ffi.Union {
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

final class pthread_barrierattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

final class random_data extends ffi.Struct {
  external ffi.Pointer<ffi.Int32> fptr;

  external ffi.Pointer<ffi.Int32> rptr;

  external ffi.Pointer<ffi.Int32> state;

  @ffi.Int()
  external int rand_type;

  @ffi.Int()
  external int rand_deg;

  @ffi.Int()
  external int rand_sep;

  external ffi.Pointer<ffi.Int32> end_ptr;
}

final class drand48_data extends ffi.Struct {
  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __x;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __old_x;

  @ffi.UnsignedShort()
  external int __c;

  @ffi.UnsignedShort()
  external int __init;

  @ffi.UnsignedLongLong()
  external int __a;
}

typedef __compar_fn_tFunction = ffi.Int Function(
    ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>);
typedef Dart__compar_fn_tFunction = int Function(
    ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>);
typedef __compar_fn_t = ffi.Pointer<ffi.NativeFunction<__compar_fn_tFunction>>;

/// Blockchain enum type
enum TWBlockchain {
  TWBlockchainBitcoin(0),
  TWBlockchainEthereum(1),
  TWBlockchainVechain(3),
  TWBlockchainTron(4),
  TWBlockchainIcon(5),
  TWBlockchainBinance(6),
  TWBlockchainRipple(7),
  TWBlockchainTezos(8),
  TWBlockchainNimiq(9),
  TWBlockchainStellar(10),
  TWBlockchainAion(11),
  TWBlockchainCosmos(12),
  TWBlockchainTheta(13),
  TWBlockchainOntology(14),
  TWBlockchainZilliqa(15),
  TWBlockchainIoTeX(16),
  TWBlockchainEOS(17),
  TWBlockchainNano(18),
  TWBlockchainNULS(19),
  TWBlockchainWaves(20),
  TWBlockchainAeternity(21),
  TWBlockchainNebulas(22),
  TWBlockchainFIO(23),
  TWBlockchainSolana(24),
  TWBlockchainHarmony(25),
  TWBlockchainNEAR(26),
  TWBlockchainAlgorand(27),
  TWBlockchainPolkadot(29),
  TWBlockchainCardano(30),
  TWBlockchainNEO(31),
  TWBlockchainFilecoin(32),
  TWBlockchainMultiversX(33),
  TWBlockchainOasisNetwork(34),
  TWBlockchainDecred(35),
  TWBlockchainZcash(36),
  TWBlockchainGroestlcoin(37),
  TWBlockchainThorchain(38),
  TWBlockchainRonin(39),
  TWBlockchainKusama(40),
  TWBlockchainNervos(41),
  TWBlockchainEverscale(42),
  TWBlockchainAptos(43),
  TWBlockchainHedera(44),
  TWBlockchainTheOpenNetwork(45),
  TWBlockchainSui(46);

  final int value;
  const TWBlockchain(this.value);

  static TWBlockchain fromValue(int value) => switch (value) {
        0 => TWBlockchainBitcoin,
        1 => TWBlockchainEthereum,
        3 => TWBlockchainVechain,
        4 => TWBlockchainTron,
        5 => TWBlockchainIcon,
        6 => TWBlockchainBinance,
        7 => TWBlockchainRipple,
        8 => TWBlockchainTezos,
        9 => TWBlockchainNimiq,
        10 => TWBlockchainStellar,
        11 => TWBlockchainAion,
        12 => TWBlockchainCosmos,
        13 => TWBlockchainTheta,
        14 => TWBlockchainOntology,
        15 => TWBlockchainZilliqa,
        16 => TWBlockchainIoTeX,
        17 => TWBlockchainEOS,
        18 => TWBlockchainNano,
        19 => TWBlockchainNULS,
        20 => TWBlockchainWaves,
        21 => TWBlockchainAeternity,
        22 => TWBlockchainNebulas,
        23 => TWBlockchainFIO,
        24 => TWBlockchainSolana,
        25 => TWBlockchainHarmony,
        26 => TWBlockchainNEAR,
        27 => TWBlockchainAlgorand,
        29 => TWBlockchainPolkadot,
        30 => TWBlockchainCardano,
        31 => TWBlockchainNEO,
        32 => TWBlockchainFilecoin,
        33 => TWBlockchainMultiversX,
        34 => TWBlockchainOasisNetwork,
        35 => TWBlockchainDecred,
        36 => TWBlockchainZcash,
        37 => TWBlockchainGroestlcoin,
        38 => TWBlockchainThorchain,
        39 => TWBlockchainRonin,
        40 => TWBlockchainKusama,
        41 => TWBlockchainNervos,
        42 => TWBlockchainEverscale,
        43 => TWBlockchainAptos,
        44 => TWBlockchainHedera,
        45 => TWBlockchainTheOpenNetwork,
        46 => TWBlockchainSui,
        _ => throw ArgumentError("Unknown value for TWBlockchain: $value"),
      };
}

/// Elliptic cruves
enum TWCurve {
  TWCurveSECP256k1(0),
  TWCurveED25519(1),
  TWCurveED25519Blake2bNano(2),
  TWCurveCurve25519(3),
  TWCurveNIST256p1(4),
  TWCurveED25519ExtendedCardano(5),
  TWCurveStarkex(6),
  TWCurveNone(7);

  final int value;
  const TWCurve(this.value);

  static TWCurve fromValue(int value) => switch (value) {
        0 => TWCurveSECP256k1,
        1 => TWCurveED25519,
        2 => TWCurveED25519Blake2bNano,
        3 => TWCurveCurve25519,
        4 => TWCurveNIST256p1,
        5 => TWCurveED25519ExtendedCardano,
        6 => TWCurveStarkex,
        7 => TWCurveNone,
        _ => throw ArgumentError("Unknown value for TWCurve: $value"),
      };
}

/// Registered HD version bytes
///
/// \see https://github.com/satoshilabs/slips/blob/master/slip-0132.md
enum TWHDVersion {
  TWHDVersionNone(0),
  TWHDVersionXPUB(76067358),
  TWHDVersionXPRV(76066276),
  TWHDVersionYPUB(77429938),
  TWHDVersionYPRV(77428856),
  TWHDVersionZPUB(78792518),
  TWHDVersionZPRV(78791436),
  TWHDVersionLTUB(27108450),
  TWHDVersionLTPV(27106558),
  TWHDVersionMTUB(28471030),
  TWHDVersionMTPV(28469138),
  TWHDVersionDPUB(50178342),
  TWHDVersionDPRV(50177256),
  TWHDVersionDGUB(49990397),
  TWHDVersionDGPV(49988504);

  final int value;
  const TWHDVersion(this.value);

  static TWHDVersion fromValue(int value) => switch (value) {
        0 => TWHDVersionNone,
        76067358 => TWHDVersionXPUB,
        76066276 => TWHDVersionXPRV,
        77429938 => TWHDVersionYPUB,
        77428856 => TWHDVersionYPRV,
        78792518 => TWHDVersionZPUB,
        78791436 => TWHDVersionZPRV,
        27108450 => TWHDVersionLTUB,
        27106558 => TWHDVersionLTPV,
        28471030 => TWHDVersionMTUB,
        28469138 => TWHDVersionMTPV,
        50178342 => TWHDVersionDPUB,
        50177256 => TWHDVersionDPRV,
        49990397 => TWHDVersionDGUB,
        49988504 => TWHDVersionDGPV,
        _ => throw ArgumentError("Unknown value for TWHDVersion: $value"),
      };
}

/// Registered human-readable parts for BIP-0173
///
/// - SeeAlso: https://github.com/satoshilabs/slips/blob/master/slip-0173.md
enum TWHRP {
  TWHRPUnknown(0),
  TWHRPBitcoin(1),
  TWHRPLitecoin(2),
  TWHRPViacoin(3),
  TWHRPGroestlcoin(4),
  TWHRPDigiByte(5),
  TWHRPMonacoin(6),
  TWHRPCosmos(7),
  TWHRPBitcoinCash(8),
  TWHRPBitcoinGold(9),
  TWHRPIoTeX(10),
  TWHRPNervos(11),
  TWHRPZilliqa(12),
  TWHRPTerra(13),
  TWHRPCryptoOrg(14),
  TWHRPKava(15),
  TWHRPOasis(16),
  TWHRPBluzelle(17),
  TWHRPBandChain(18),
  TWHRPMultiversX(19),
  TWHRPSecret(20),
  TWHRPAgoric(21),
  TWHRPBinance(22),
  TWHRPECash(23),
  TWHRPTHORChain(24),
  TWHRPHarmony(25),
  TWHRPCardano(26),
  TWHRPQtum(27),
  TWHRPNativeInjective(28),
  TWHRPOsmosis(29),
  TWHRPTerraV2(30),
  TWHRPCoreum(31),
  TWHRPNativeCanto(32),
  TWHRPSommelier(33),
  TWHRPFetchAI(34),
  TWHRPMars(35),
  TWHRPUmee(36),
  TWHRPQuasar(37),
  TWHRPPersistence(38),
  TWHRPAkash(39),
  TWHRPNoble(40),
  TWHRPStargaze(41),
  TWHRPNativeEvmos(42),
  TWHRPJuno(43),
  TWHRPStride(44),
  TWHRPAxelar(45),
  TWHRPCrescent(46),
  TWHRPKujira(47),
  TWHRPComdex(48),
  TWHRPNeutron(49);

  final int value;
  const TWHRP(this.value);

  static TWHRP fromValue(int value) => switch (value) {
        0 => TWHRPUnknown,
        1 => TWHRPBitcoin,
        2 => TWHRPLitecoin,
        3 => TWHRPViacoin,
        4 => TWHRPGroestlcoin,
        5 => TWHRPDigiByte,
        6 => TWHRPMonacoin,
        7 => TWHRPCosmos,
        8 => TWHRPBitcoinCash,
        9 => TWHRPBitcoinGold,
        10 => TWHRPIoTeX,
        11 => TWHRPNervos,
        12 => TWHRPZilliqa,
        13 => TWHRPTerra,
        14 => TWHRPCryptoOrg,
        15 => TWHRPKava,
        16 => TWHRPOasis,
        17 => TWHRPBluzelle,
        18 => TWHRPBandChain,
        19 => TWHRPMultiversX,
        20 => TWHRPSecret,
        21 => TWHRPAgoric,
        22 => TWHRPBinance,
        23 => TWHRPECash,
        24 => TWHRPTHORChain,
        25 => TWHRPHarmony,
        26 => TWHRPCardano,
        27 => TWHRPQtum,
        28 => TWHRPNativeInjective,
        29 => TWHRPOsmosis,
        30 => TWHRPTerraV2,
        31 => TWHRPCoreum,
        32 => TWHRPNativeCanto,
        33 => TWHRPSommelier,
        34 => TWHRPFetchAI,
        35 => TWHRPMars,
        36 => TWHRPUmee,
        37 => TWHRPQuasar,
        38 => TWHRPPersistence,
        39 => TWHRPAkash,
        40 => TWHRPNoble,
        41 => TWHRPStargaze,
        42 => TWHRPNativeEvmos,
        43 => TWHRPJuno,
        44 => TWHRPStride,
        45 => TWHRPAxelar,
        46 => TWHRPCrescent,
        47 => TWHRPKujira,
        48 => TWHRPComdex,
        49 => TWHRPNeutron,
        _ => throw ArgumentError("Unknown value for TWHRP: $value"),
      };
}

/// HD wallet purpose
///
/// \see https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
/// \see https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki
/// \see https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki
enum TWPurpose {
  TWPurposeBIP44(44),
  TWPurposeBIP49(49),
  TWPurposeBIP84(84),
  TWPurposeBIP1852(1852);

  final int value;
  const TWPurpose(this.value);

  static TWPurpose fromValue(int value) => switch (value) {
        44 => TWPurposeBIP44,
        49 => TWPurposeBIP49,
        84 => TWPurposeBIP84,
        1852 => TWPurposeBIP1852,
        _ => throw ArgumentError("Unknown value for TWPurpose: $value"),
      };
}

/// Defines a resizable block of data.
///
/// The implementantion of these methods should be language-specific to minimize translation overhead. For instance it
/// should be a `jbyteArray` for Java and an `NSData` for Swift.
typedef TWData = ffi.Void;
typedef DartTWData = void;

/// Defines a resizable string.
///
/// The implementantion of these methods should be language-specific to minimize translation
/// overhead. For instance it should be a `jstring` for Java and an `NSString` for Swift. Create
/// allocates memory, the delete call should be called at the end to release memory.
typedef TWString = ffi.Void;
typedef DartTWString = void;

/// Non-default coin address derivation names (default, unnamed derivations are not included).
enum TWDerivation {
  TWDerivationDefault(0),
  TWDerivationCustom(1),
  TWDerivationBitcoinSegwit(2),
  TWDerivationBitcoinLegacy(3),
  TWDerivationBitcoinTestnet(4),
  TWDerivationLitecoinLegacy(5),
  TWDerivationSolanaSolana(6);

  final int value;
  const TWDerivation(this.value);

  static TWDerivation fromValue(int value) => switch (value) {
        0 => TWDerivationDefault,
        1 => TWDerivationCustom,
        2 => TWDerivationBitcoinSegwit,
        3 => TWDerivationBitcoinLegacy,
        4 => TWDerivationBitcoinTestnet,
        5 => TWDerivationLitecoinLegacy,
        6 => TWDerivationSolanaSolana,
        _ => throw ArgumentError("Unknown value for TWDerivation: $value"),
      };
}

/// Public key types
enum TWPublicKeyType {
  TWPublicKeyTypeSECP256k1(0),
  TWPublicKeyTypeSECP256k1Extended(1),
  TWPublicKeyTypeNIST256p1(2),
  TWPublicKeyTypeNIST256p1Extended(3),
  TWPublicKeyTypeED25519(4),
  TWPublicKeyTypeED25519Blake2b(5),
  TWPublicKeyTypeCURVE25519(6),
  TWPublicKeyTypeED25519Cardano(7),
  TWPublicKeyTypeStarkex(8);

  final int value;
  const TWPublicKeyType(this.value);

  static TWPublicKeyType fromValue(int value) => switch (value) {
        0 => TWPublicKeyTypeSECP256k1,
        1 => TWPublicKeyTypeSECP256k1Extended,
        2 => TWPublicKeyTypeNIST256p1,
        3 => TWPublicKeyTypeNIST256p1Extended,
        4 => TWPublicKeyTypeED25519,
        5 => TWPublicKeyTypeED25519Blake2b,
        6 => TWPublicKeyTypeCURVE25519,
        7 => TWPublicKeyTypeED25519Cardano,
        8 => TWPublicKeyTypeStarkex,
        _ => throw ArgumentError("Unknown value for TWPublicKeyType: $value"),
      };
}

/// Represents a private key.
final class TWPrivateKey extends ffi.Opaque {}

/// Represents a public key.
final class TWPublicKey extends ffi.Opaque {}

/// Coin type for Level 2 of BIP44.
///
/// \see https://github.com/satoshilabs/slips/blob/master/slip-0044.md
enum TWCoinType {
  TWCoinTypeAeternity(457),
  TWCoinTypeAion(425),
  TWCoinTypeBinance(714),
  TWCoinTypeBitcoin(0),
  TWCoinTypeBitcoinCash(145),
  TWCoinTypeBitcoinGold(156),
  TWCoinTypeCallisto(820),
  TWCoinTypeCardano(1815),
  TWCoinTypeCosmos(118),
  TWCoinTypeDash(5),
  TWCoinTypeDecred(42),
  TWCoinTypeDigiByte(20),
  TWCoinTypeDogecoin(3),
  TWCoinTypeEOS(194),
  TWCoinTypeWAX(14001),
  TWCoinTypeEthereum(60),
  TWCoinTypeEthereumClassic(61),
  TWCoinTypeFIO(235),
  TWCoinTypeGoChain(6060),
  TWCoinTypeGroestlcoin(17),
  TWCoinTypeICON(74),
  TWCoinTypeIoTeX(304),
  TWCoinTypeKava(459),
  TWCoinTypeKin(2017),
  TWCoinTypeLitecoin(2),
  TWCoinTypeMonacoin(22),
  TWCoinTypeNebulas(2718),
  TWCoinTypeNULS(8964),
  TWCoinTypeNano(165),
  TWCoinTypeNEAR(397),
  TWCoinTypeNimiq(242),
  TWCoinTypeOntology(1024),
  TWCoinTypePOANetwork(178),
  TWCoinTypeQtum(2301),
  TWCoinTypeXRP(144),
  TWCoinTypeSolana(501),
  TWCoinTypeStellar(148),
  TWCoinTypeTezos(1729),
  TWCoinTypeTheta(500),
  TWCoinTypeThunderCore(1001),
  TWCoinTypeNEO(888),
  TWCoinTypeTomoChain(889),
  TWCoinTypeTron(195),
  TWCoinTypeVeChain(818),
  TWCoinTypeViacoin(14),
  TWCoinTypeWanchain(5718350),
  TWCoinTypeZcash(133),
  TWCoinTypeFiro(136),
  TWCoinTypeZilliqa(313),
  TWCoinTypeZelcash(19167),
  TWCoinTypeRavencoin(175),
  TWCoinTypeWaves(5741564),
  TWCoinTypeTerra(330),
  TWCoinTypeTerraV2(10000330),
  TWCoinTypeHarmony(1023),
  TWCoinTypeAlgorand(283),
  TWCoinTypeKusama(434),
  TWCoinTypePolkadot(354),
  TWCoinTypeFilecoin(461),
  TWCoinTypeMultiversX(508),
  TWCoinTypeBandChain(494),
  TWCoinTypeSmartChainLegacy(10000714),
  TWCoinTypeSmartChain(20000714),
  TWCoinTypeOasis(474),
  TWCoinTypePolygon(966),
  TWCoinTypeTHORChain(931),
  TWCoinTypeBluzelle(483),
  TWCoinTypeOptimism(10000070),
  TWCoinTypeZksync(10000324),
  TWCoinTypeArbitrum(10042221),
  TWCoinTypeECOChain(10000553),
  TWCoinTypeAvalancheCChain(10009000),
  TWCoinTypeXDai(10000100),
  TWCoinTypeFantom(10000250),
  TWCoinTypeCryptoOrg(394),
  TWCoinTypeCelo(52752),
  TWCoinTypeRonin(10002020),
  TWCoinTypeOsmosis(10000118),
  TWCoinTypeECash(899),
  TWCoinTypeCronosChain(10000025),
  TWCoinTypeSmartBitcoinCash(10000145),
  TWCoinTypeKuCoinCommunityChain(10000321),
  TWCoinTypeBoba(10000288),
  TWCoinTypeMetis(1001088),
  TWCoinTypeAurora(1323161554),
  TWCoinTypeEvmos(10009001),
  TWCoinTypeNativeEvmos(20009001),
  TWCoinTypeMoonriver(10001285),
  TWCoinTypeMoonbeam(10001284),
  TWCoinTypeKavaEvm(10002222),
  TWCoinTypeKlaytn(10008217),
  TWCoinTypeMeter(18000),
  TWCoinTypeOKXChain(996),
  TWCoinTypeNervos(309),
  TWCoinTypeEverscale(396),
  TWCoinTypeAptos(637),
  TWCoinTypeHedera(3030),
  TWCoinTypeSecret(529),
  TWCoinTypeNativeInjective(10000060),
  TWCoinTypeAgoric(564),
  TWCoinTypeTON(607),
  TWCoinTypeSui(784),
  TWCoinTypeStargaze(20000118),
  TWCoinTypePolygonzkEVM(10001101),
  TWCoinTypeJuno(30000118),
  TWCoinTypeStride(40000118),
  TWCoinTypeAxelar(50000118),
  TWCoinTypeCrescent(60000118),
  TWCoinTypeKujira(70000118),
  TWCoinTypeIoTeXEVM(10004689),
  TWCoinTypeNativeCanto(10007700),
  TWCoinTypeComdex(80000118),
  TWCoinTypeNeutron(90000118),
  TWCoinTypeSommelier(11000118),
  TWCoinTypeFetchAI(12000118),
  TWCoinTypeMars(13000118),
  TWCoinTypeUmee(14000118),
  TWCoinTypeCoreum(10000990),
  TWCoinTypeQuasar(15000118),
  TWCoinTypePersistence(16000118),
  TWCoinTypeAkash(17000118),
  TWCoinTypeNoble(18000118);

  final int value;
  const TWCoinType(this.value);

  static TWCoinType fromValue(int value) => switch (value) {
        457 => TWCoinTypeAeternity,
        425 => TWCoinTypeAion,
        714 => TWCoinTypeBinance,
        0 => TWCoinTypeBitcoin,
        145 => TWCoinTypeBitcoinCash,
        156 => TWCoinTypeBitcoinGold,
        820 => TWCoinTypeCallisto,
        1815 => TWCoinTypeCardano,
        118 => TWCoinTypeCosmos,
        5 => TWCoinTypeDash,
        42 => TWCoinTypeDecred,
        20 => TWCoinTypeDigiByte,
        3 => TWCoinTypeDogecoin,
        194 => TWCoinTypeEOS,
        14001 => TWCoinTypeWAX,
        60 => TWCoinTypeEthereum,
        61 => TWCoinTypeEthereumClassic,
        235 => TWCoinTypeFIO,
        6060 => TWCoinTypeGoChain,
        17 => TWCoinTypeGroestlcoin,
        74 => TWCoinTypeICON,
        304 => TWCoinTypeIoTeX,
        459 => TWCoinTypeKava,
        2017 => TWCoinTypeKin,
        2 => TWCoinTypeLitecoin,
        22 => TWCoinTypeMonacoin,
        2718 => TWCoinTypeNebulas,
        8964 => TWCoinTypeNULS,
        165 => TWCoinTypeNano,
        397 => TWCoinTypeNEAR,
        242 => TWCoinTypeNimiq,
        1024 => TWCoinTypeOntology,
        178 => TWCoinTypePOANetwork,
        2301 => TWCoinTypeQtum,
        144 => TWCoinTypeXRP,
        501 => TWCoinTypeSolana,
        148 => TWCoinTypeStellar,
        1729 => TWCoinTypeTezos,
        500 => TWCoinTypeTheta,
        1001 => TWCoinTypeThunderCore,
        888 => TWCoinTypeNEO,
        889 => TWCoinTypeTomoChain,
        195 => TWCoinTypeTron,
        818 => TWCoinTypeVeChain,
        14 => TWCoinTypeViacoin,
        5718350 => TWCoinTypeWanchain,
        133 => TWCoinTypeZcash,
        136 => TWCoinTypeFiro,
        313 => TWCoinTypeZilliqa,
        19167 => TWCoinTypeZelcash,
        175 => TWCoinTypeRavencoin,
        5741564 => TWCoinTypeWaves,
        330 => TWCoinTypeTerra,
        10000330 => TWCoinTypeTerraV2,
        1023 => TWCoinTypeHarmony,
        283 => TWCoinTypeAlgorand,
        434 => TWCoinTypeKusama,
        354 => TWCoinTypePolkadot,
        461 => TWCoinTypeFilecoin,
        508 => TWCoinTypeMultiversX,
        494 => TWCoinTypeBandChain,
        10000714 => TWCoinTypeSmartChainLegacy,
        20000714 => TWCoinTypeSmartChain,
        474 => TWCoinTypeOasis,
        966 => TWCoinTypePolygon,
        931 => TWCoinTypeTHORChain,
        483 => TWCoinTypeBluzelle,
        10000070 => TWCoinTypeOptimism,
        10000324 => TWCoinTypeZksync,
        10042221 => TWCoinTypeArbitrum,
        10000553 => TWCoinTypeECOChain,
        10009000 => TWCoinTypeAvalancheCChain,
        10000100 => TWCoinTypeXDai,
        10000250 => TWCoinTypeFantom,
        394 => TWCoinTypeCryptoOrg,
        52752 => TWCoinTypeCelo,
        10002020 => TWCoinTypeRonin,
        10000118 => TWCoinTypeOsmosis,
        899 => TWCoinTypeECash,
        10000025 => TWCoinTypeCronosChain,
        10000145 => TWCoinTypeSmartBitcoinCash,
        10000321 => TWCoinTypeKuCoinCommunityChain,
        10000288 => TWCoinTypeBoba,
        1001088 => TWCoinTypeMetis,
        1323161554 => TWCoinTypeAurora,
        10009001 => TWCoinTypeEvmos,
        20009001 => TWCoinTypeNativeEvmos,
        10001285 => TWCoinTypeMoonriver,
        10001284 => TWCoinTypeMoonbeam,
        10002222 => TWCoinTypeKavaEvm,
        10008217 => TWCoinTypeKlaytn,
        18000 => TWCoinTypeMeter,
        996 => TWCoinTypeOKXChain,
        309 => TWCoinTypeNervos,
        396 => TWCoinTypeEverscale,
        637 => TWCoinTypeAptos,
        3030 => TWCoinTypeHedera,
        529 => TWCoinTypeSecret,
        10000060 => TWCoinTypeNativeInjective,
        564 => TWCoinTypeAgoric,
        607 => TWCoinTypeTON,
        784 => TWCoinTypeSui,
        20000118 => TWCoinTypeStargaze,
        10001101 => TWCoinTypePolygonzkEVM,
        30000118 => TWCoinTypeJuno,
        40000118 => TWCoinTypeStride,
        50000118 => TWCoinTypeAxelar,
        60000118 => TWCoinTypeCrescent,
        70000118 => TWCoinTypeKujira,
        10004689 => TWCoinTypeIoTeXEVM,
        10007700 => TWCoinTypeNativeCanto,
        80000118 => TWCoinTypeComdex,
        90000118 => TWCoinTypeNeutron,
        11000118 => TWCoinTypeSommelier,
        12000118 => TWCoinTypeFetchAI,
        13000118 => TWCoinTypeMars,
        14000118 => TWCoinTypeUmee,
        10000990 => TWCoinTypeCoreum,
        15000118 => TWCoinTypeQuasar,
        16000118 => TWCoinTypePersistence,
        17000118 => TWCoinTypeAkash,
        18000118 => TWCoinTypeNoble,
        _ => throw ArgumentError("Unknown value for TWCoinType: $value"),
      };
}

/// Filecoin address type.
enum TWFilecoinAddressType {
  TWFilecoinAddressTypeDefault(0),
  TWFilecoinAddressTypeDelegated(1);

  final int value;
  const TWFilecoinAddressType(this.value);

  static TWFilecoinAddressType fromValue(int value) => switch (value) {
        0 => TWFilecoinAddressTypeDefault,
        1 => TWFilecoinAddressTypeDelegated,
        _ => throw ArgumentError(
            "Unknown value for TWFilecoinAddressType: $value"),
      };
}

/// Represents an address in C++ for almost any blockchain.
final class TWAnyAddress extends ffi.Opaque {}

/// Represents an Account in C++ with address, coin type and public key info, an item within a keystore.
final class TWAccount extends ffi.Opaque {}

/// CoinTypeConfiguration functions
final class TWCoinTypeConfiguration extends ffi.Struct {
  @ffi.Uint8()
  external int unused;
}

typedef TWString1 = ffi.Void;
typedef DartTWString1 = void;

/// Defines a resizable block of data.
///
/// The implementantion of these methods should be language-specific to minimize translation overhead. For instance it
/// should be a `jbyteArray` for Java and an `NSData` for Swift.
typedef TWData1 = ffi.Void;
typedef DartTWData1 = void;

/// Mnemonic validate / lookup functions
final class TWMnemonic extends ffi.Opaque {}

/// Represents a BIP44 DerivationPath in C++.
final class TWDerivationPath extends ffi.Opaque {}

final class TWDerivationPathIndex extends ffi.Opaque {}

/// Hierarchical Deterministic (HD) Wallet
final class TWHDWallet extends ffi.Opaque {}

/// Preset encryption parameter with different security strength, for key store
enum TWStoredKeyEncryptionLevel {
  /// Default, which is one of the below values, determined by the implementation.
  TWStoredKeyEncryptionLevelDefault(0),

  /// Minimal sufficient level of encryption strength (scrypt 4096)
  TWStoredKeyEncryptionLevelMinimal(1),

  /// Weak encryption strength (scrypt 16k)
  TWStoredKeyEncryptionLevelWeak(2),

  /// Standard level of encryption strength (scrypt 262k)
  TWStoredKeyEncryptionLevelStandard(3);

  final int value;
  const TWStoredKeyEncryptionLevel(this.value);

  static TWStoredKeyEncryptionLevel fromValue(int value) => switch (value) {
        0 => TWStoredKeyEncryptionLevelDefault,
        1 => TWStoredKeyEncryptionLevelMinimal,
        2 => TWStoredKeyEncryptionLevelWeak,
        3 => TWStoredKeyEncryptionLevelStandard,
        _ => throw ArgumentError(
            "Unknown value for TWStoredKeyEncryptionLevel: $value"),
      };
}

/// Preset encryption kind
enum TWStoredKeyEncryption {
  TWStoredKeyEncryptionAes128Ctr(0),
  TWStoredKeyEncryptionAes128Cbc(1),
  TWStoredKeyEncryptionAes192Ctr(2),
  TWStoredKeyEncryptionAes256Ctr(3);

  final int value;
  const TWStoredKeyEncryption(this.value);

  static TWStoredKeyEncryption fromValue(int value) => switch (value) {
        0 => TWStoredKeyEncryptionAes128Ctr,
        1 => TWStoredKeyEncryptionAes128Cbc,
        2 => TWStoredKeyEncryptionAes192Ctr,
        3 => TWStoredKeyEncryptionAes256Ctr,
        _ => throw ArgumentError(
            "Unknown value for TWStoredKeyEncryption: $value"),
      };
}

/// Represents a key stored as an encrypted file.
final class TWStoredKey extends ffi.Opaque {}

const int __bool_true_false_are_defined = 1;

const int true1 = 1;

const int false1 = 0;

const int NULL = 0;

const int _STDINT_H = 1;

const int _FEATURES_H = 1;

const int _DEFAULT_SOURCE = 1;

const int __GLIBC_USE_ISOC2X = 1;

const int __USE_ISOC11 = 1;

const int __USE_ISOC99 = 1;

const int __USE_ISOC95 = 1;

const int _POSIX_SOURCE = 1;

const int _POSIX_C_SOURCE = 200809;

const int __USE_POSIX = 1;

const int __USE_POSIX2 = 1;

const int __USE_POSIX199309 = 1;

const int __USE_POSIX199506 = 1;

const int __USE_XOPEN2K = 1;

const int __USE_XOPEN2K8 = 1;

const int _ATFILE_SOURCE = 1;

const int __WORDSIZE = 64;

const int __WORDSIZE_TIME64_COMPAT32 = 1;

const int __SYSCALL_WORDSIZE = 64;

const int __TIMESIZE = 64;

const int __USE_MISC = 1;

const int __USE_ATFILE = 1;

const int __USE_FORTIFY_LEVEL = 0;

const int __GLIBC_USE_DEPRECATED_GETS = 0;

const int __GLIBC_USE_DEPRECATED_SCANF = 0;

const int __GLIBC_USE_C2X_STRTOL = 1;

const int _STDC_PREDEF_H = 1;

const int __STDC_IEC_559__ = 1;

const int __STDC_IEC_60559_BFP__ = 201404;

const int __STDC_IEC_559_COMPLEX__ = 1;

const int __STDC_IEC_60559_COMPLEX__ = 201404;

const int __STDC_ISO_10646__ = 201706;

const int __GNU_LIBRARY__ = 6;

const int __GLIBC__ = 2;

const int __GLIBC_MINOR__ = 39;

const int _SYS_CDEFS_H = 1;

const int __THROW = 1;

const int __THROWNL = 1;

const int __glibc_c99_flexarr_available = 1;

const int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = 0;

const int __HAVE_GENERIC_SELECTION = 0;

const int __GLIBC_USE_LIB_EXT2 = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_TYPES_EXT = 1;

const int _BITS_TYPES_H = 1;

const int _BITS_TYPESIZES_H = 1;

const int __OFF_T_MATCHES_OFF64_T = 1;

const int __INO_T_MATCHES_INO64_T = 1;

const int __RLIM_T_MATCHES_RLIM64_T = 1;

const int __STATFS_MATCHES_STATFS64 = 1;

const int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = 1;

const int __FD_SETSIZE = 1024;

const int _BITS_TIME64_H = 1;

const int _BITS_WCHAR_H = 1;

const int __WCHAR_MAX = 2147483647;

const int __WCHAR_MIN = -2147483648;

const int _BITS_STDINT_INTN_H = 1;

const int _BITS_STDINT_UINTN_H = 1;

const int _BITS_STDINT_LEAST_H = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -9223372036854775808;

const int INT_FAST32_MIN = -9223372036854775808;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 9223372036854775807;

const int INT_FAST32_MAX = 9223372036854775807;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = -1;

const int UINT_FAST32_MAX = -1;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int SIZE_MAX = -1;

const int WCHAR_MIN = -2147483648;

const int WCHAR_MAX = 2147483647;

const int WINT_MIN = 0;

const int WINT_MAX = 4294967295;

const int _STDLIB_H = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WSTOPPED = 2;

const int WEXITED = 4;

const int WCONTINUED = 8;

const int WNOWAIT = 16777216;

const int __WNOTHREAD = 536870912;

const int __WALL = 1073741824;

const int __WCLONE = 2147483648;

const int __W_CONTINUED = 65535;

const int __WCOREFLAG = 128;

const int __HAVE_FLOAT128 = 0;

const int __HAVE_DISTINCT_FLOAT128 = 0;

const int __HAVE_FLOAT64X = 1;

const int __HAVE_FLOAT64X_LONG_DOUBLE = 1;

const int __HAVE_FLOAT16 = 0;

const int __HAVE_FLOAT32 = 1;

const int __HAVE_FLOAT64 = 1;

const int __HAVE_FLOAT32X = 1;

const int __HAVE_FLOAT128X = 0;

const int __HAVE_DISTINCT_FLOAT16 = 0;

const int __HAVE_DISTINCT_FLOAT32 = 0;

const int __HAVE_DISTINCT_FLOAT64 = 0;

const int __HAVE_DISTINCT_FLOAT32X = 0;

const int __HAVE_DISTINCT_FLOAT64X = 0;

const int __HAVE_DISTINCT_FLOAT128X = 0;

const int __HAVE_FLOAT128_UNLIKE_LDBL = 0;

const int __HAVE_FLOATN_NOT_TYPEDEF = 0;

const int __ldiv_t_defined = 1;

const int __lldiv_t_defined = 1;

const int RAND_MAX = 2147483647;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int _SYS_TYPES_H = 1;

const int __clock_t_defined = 1;

const int __clockid_t_defined = 1;

const int __time_t_defined = 1;

const int __timer_t_defined = 1;

const int __BIT_TYPES_DEFINED__ = 1;

const int _ENDIAN_H = 1;

const int _BITS_ENDIAN_H = 1;

const int __LITTLE_ENDIAN = 1234;

const int __BIG_ENDIAN = 4321;

const int __PDP_ENDIAN = 3412;

const int _BITS_ENDIANNESS_H = 1;

const int __BYTE_ORDER = 1234;

const int __FLOAT_WORD_ORDER = 1234;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int BYTE_ORDER = 1234;

const int _BITS_BYTESWAP_H = 1;

const int _BITS_UINTN_IDENTITY_H = 1;

const int _SYS_SELECT_H = 1;

const int __sigset_t_defined = 1;

const int _SIGSET_NWORDS = 16;

const int __timeval_defined = 1;

const int _STRUCT_TIMESPEC = 1;

const int __NFDBITS = 64;

const int FD_SETSIZE = 1024;

const int NFDBITS = 64;

const int _BITS_PTHREADTYPES_COMMON_H = 1;

const int _THREAD_SHARED_TYPES_H = 1;

const int _BITS_PTHREADTYPES_ARCH_H = 1;

const int __SIZEOF_PTHREAD_MUTEX_T = 40;

const int __SIZEOF_PTHREAD_ATTR_T = 56;

const int __SIZEOF_PTHREAD_RWLOCK_T = 56;

const int __SIZEOF_PTHREAD_BARRIER_T = 32;

const int __SIZEOF_PTHREAD_MUTEXATTR_T = 4;

const int __SIZEOF_PTHREAD_COND_T = 48;

const int __SIZEOF_PTHREAD_CONDATTR_T = 4;

const int __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;

const int __SIZEOF_PTHREAD_BARRIERATTR_T = 4;

const int _THREAD_MUTEX_INTERNAL_H = 1;

const int __PTHREAD_MUTEX_HAVE_PREV = 1;

const int __PTHREAD_RWLOCK_ELISION_EXTRA = 0;

const int __have_pthread_attr_t = 1;

const int _ALLOCA_H = 1;
