name: Flutter Build and Release

on:
  push:
    branches:
      - develop
      - main
    paths-ignore:
      - ".github/**"
      - "README.md"
  pull_request:
    branches:
      - develop
      - main
    paths-ignore:
      - ".github/**"
      - "README.md"
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag"
        required: false
        type: string
      distribution_type:
        description: "Distribution type for macOS"
        required: false
        type: choice
        options:
          - "both"
          - "testflight"
          - "developer-id"
        default: "both"

jobs:
  build:
    env:
      GRPC_BUILD_ENABLE_CCACHE: "ON"
      GH_TOKEN: ${{ secrets.GNUS_TOKEN_1 }}
    runs-on: ${{matrix.host}}
    container:
      image: ${{matrix.container}}
      credentials:
        username: ${{github.actor}}
        password: ${{secrets.GNUS_TOKEN_1}}
    strategy:
      fail-fast: false
      matrix:
        target: [Android, iOS, OSX, Linux, Windows]
        build-type: [Release]
        abi: [""]
        include:
          - target: Linux
            host: ubuntu-22.04
            flutter-platform: linux
            abi: x86_64
            build-type: Release
          - target: Linux
            host: ubuntu-24.04-arm
            flutter-platform: linux
            abi: aarch64
            build-type: Release
            container: ghcr.io/geniusventures/debian-bullseye:latest
          - target: Windows
            host: windows-latest
            flutter-platform: windows
          - target: OSX
            host: macos-latest
            flutter-platform: macos
          - target: Android
            host: ubuntu-latest
            flutter-platform: apk
          - target: iOS
            host: macos-latest
            flutter-platform: ios
        exclude:
          - target: Linux
            abi: ""
    steps:
      - name: Configure Linux host
        if: ${{ runner.os == 'Linux'}}
        run: |
          sudo apt update
          sudo update-alternatives --install /usr/bin/cc cc $(which clang) 100
          sudo update-alternatives --install /usr/bin/c++ c++ $(which clang++) 100
          sudo update-alternatives --set cc $(which clang)
          sudo update-alternatives --set c++ $(which clang++)

          sudo apt install ninja-build libvulkan-dev libzstd-dev libsecret-1-dev -y

          # Flutter Linux desktop dependencies
          if [ "${{ matrix.target }}" = "Linux" ]; then
            sudo apt install -y libgtk-3-dev jq
          fi

          echo "CMAKE_GENERATOR=Ninja" >> $GITHUB_ENV

      - name: Configure Windows host
        if: ${{ runner.os == 'Windows'}}
        run: |
          choco install ccache -A

      - name: Configure macOS host
        if: ${{ runner.os == 'macOS' }}
        run: |
          brew install ccache ninja bash gnu-tar
          PATH="$HOMEBREW_PREFIX/opt/gnu-tar/libexec/gnubin:$PATH"
          echo "PATH=$PATH" >> $GITHUB_ENV
          echo "CMAKE_GENERATOR=Ninja" >> $GITHUB_ENV

      - name: Install Apple certificates and provisioning profiles for macOS
        if: ${{ runner.os == 'macOS' }}
        env:
          # TestFlight/App Store certificates
          DEV_DISTRIBUTION_SIGNER_CERT_BASE64: ${{ secrets.DEV_DISTRIBUTION_SIGNER_CERT_BASE_64 }}
          DEV_DISTRIBUTION_IOS_PROVISION_BASE64: ${{ secrets.DEV_DISTRIBUTION_IOS_PROVISIONING_PROFILE_BASE_64 }}
          DEV_DISTRIBUTION_MAC_PROVISION_BASE64: ${{ secrets.DEV_DISTRIBUTION_MAC_PROVISIONING_PROFILE_BASE_64 }}
          DEV_DISTRIBUTION_INSTALLER_CERT_BASE_64: ${{ secrets.DEV_DISTRIBUTION_INSTALLER_CERT_BASE_64 }}
          
          # Developer ID certificates for direct distribution
          DEVELOPER_ID_APP_CERT_BASE64: ${{ secrets.DEVELOPER_ID_APP_CERT_BASE64 }}
          DEVELOPER_ID_INSTALLER_CERT_BASE64: ${{ secrets.DEVELOPER_ID_INSTALLER_CERT_BASE64 }}
          DEVELOPER_ID_PROVISION_BASE64: ${{ secrets.DEVELOPER_ID_PROVISION_BASE64 }}
          
          # Common secrets
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
          DEV_DISTRIBUTION_P12_PASSWORD: ${{ secrets.DEV_DISTRIBUTION_P12_PASSWORD }}
          DEVELOPER_ID_P12_PASSWORD: ${{ secrets.DEVELOPER_ID_P12_PASSWORD }}
          
          # Notarization
          APPLE_ID: ${{ secrets.WALLET_NOTARIZE_APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          NOTARIZATION_PASSWORD: ${{ secrets.WALLET_NOTARIZATION_PASSWORD }}
        run: |
          # create variables
          DEV_DISTRIBUTION_SIGNER_CERT_PATH=$RUNNER_TEMP/signer_certificate.p12
          DEV_DISTRIBUTION_INSTALLER_CERT_PATH=$RUNNER_TEMP/installer_certificate.cer
          DEVELOPER_ID_APP_CERT_PATH=$RUNNER_TEMP/developer_id_app.cer
          DEVELOPER_ID_INSTALLER_CERT_PATH=$RUNNER_TEMP/developer_id_installer.p12
          
          MP_PATH=$RUNNER_TEMP/build_pp.mobileprovision
          APP_STORE_PP_PATH=$RUNNER_TEMP/app_store_pp.provisionprofile
          DEVELOPER_ID_PP_PATH=$RUNNER_TEMP/developer_id_pp.provisionprofile
          
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # import certificates and provisioning profiles from secrets
          echo -n "$DEV_DISTRIBUTION_SIGNER_CERT_BASE64" | base64 --decode -o $DEV_DISTRIBUTION_SIGNER_CERT_PATH
          echo -n "$DEV_DISTRIBUTION_INSTALLER_CERT_BASE_64" | base64 --decode -o $DEV_DISTRIBUTION_INSTALLER_CERT_PATH
          echo -n "$DEV_DISTRIBUTION_IOS_PROVISION_BASE64" | base64 --decode -o $MP_PATH
          echo -n "$DEV_DISTRIBUTION_MAC_PROVISION_BASE64" | base64 --decode -o $APP_STORE_PP_PATH
          
          # Developer ID certificates and provisioning profile
          echo -n "$DEVELOPER_ID_APP_CERT_BASE64" | base64 --decode -o $DEVELOPER_ID_APP_CERT_PATH
          echo -n "$DEVELOPER_ID_INSTALLER_CERT_BASE64" | base64 --decode -o $DEVELOPER_ID_INSTALLER_CERT_PATH
          echo -n "$DEVELOPER_ID_PROVISION_BASE64" | base64 --decode -o $DEVELOPER_ID_PP_PATH

          # create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # import certificates to keychain
          security import $DEV_DISTRIBUTION_SIGNER_CERT_PATH -P "$DEV_DISTRIBUTION_P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security import $DEV_DISTRIBUTION_INSTALLER_CERT_PATH -P "$DEV_DISTRIBUTION_P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          
          # Import Developer ID certificates - handle different formats
          if [[ "$DEVELOPER_ID_APP_CERT_PATH" == *.cer ]]; then
            # .cer file doesn't need password
            security import $DEVELOPER_ID_APP_CERT_PATH -A -t cert -k $KEYCHAIN_PATH
          else
            # .p12 file needs password
            security import $DEVELOPER_ID_APP_CERT_PATH -P "$DEVELOPER_ID_P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          fi
          
          security import $DEVELOPER_ID_INSTALLER_CERT_PATH -P "$DEVELOPER_ID_P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychains -d user -s $KEYCHAIN_PATH
          
          echo "=== Available identities in keychain ==="
          security find-identity -v
          
          echo "=== Searching for specific certificate types ==="
          security find-identity -v -p codesigning
          
          echo "=== All certificates in keychain ==="
          security dump-keychain $KEYCHAIN_PATH | grep -A 5 -B 5 "Developer\|3rd Party"

          # apply provisioning profiles
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          mkdir -p ~/Library/Developer/Xcode/UserData/Provisioning\ Profiles
          
          # App Store profiles
          cp $APP_STORE_PP_PATH ~/Library/MobileDevice/Provisioning\ Profiles/
          cp $APP_STORE_PP_PATH ~/Library/Developer/Xcode/UserData/Provisioning\ Profiles/
          cp $MP_PATH ~/Library/MobileDevice/Provisioning\ Profiles/
          cp $MP_PATH ~/Library/Developer/Xcode/UserData/Provisioning\ Profiles/
          
          # Developer ID profile
          cp $DEVELOPER_ID_PP_PATH ~/Library/MobileDevice/Provisioning\ Profiles/
          cp $DEVELOPER_ID_PP_PATH ~/Library/Developer/Xcode/UserData/Provisioning\ Profiles/

          echo "Finished importing certificates and provisioning profiles"
        shell: bash

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: "master"
          flutter-version: 3.32.5

      - name: Set current branch
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ "${{ github.event.inputs.tag }}" ]; then
              CURRENT_BRANCH="${{ github.event.inputs.tag }}"
              IS_TAG=true
          elif ${{github.event_name == 'pull_request'}}; then
              CURRENT_BRANCH=${{ github.event.pull_request.head.ref }}
              IS_TAG=false
          else
              CURRENT_BRANCH=$GITHUB_REF_NAME
              IS_TAG=false
          fi
          echo "CURRENT_BRANCH=${CURRENT_BRANCH}" >> $GITHUB_ENV
          echo "IS_TAG=${IS_TAG}" >>$GITHUB_ENV
        shell: bash

      - name: Checkout GeniusWallet
        uses: actions/checkout@v4
        with:
          submodules: "recursive"

      - name: Configure Android keystore
        if: ${{ matrix.target == 'Android' }}
        run: |
          # Create the android directory if it doesn't exist
          mkdir -p android/app
          
          # Decode and save the debug keystore to android/app/ directory
          echo "${{ secrets.DEBUG_KEYSTORE_BASE64 }}" | base64 --decode > android/app/keystore.jks
          
          echo "storePassword=${{ secrets.KEYSTORE_PASSWORD }}" > android/key.properties
          echo "keyPassword=${{ secrets.KEY_PASSWORD }}" >> android/key.properties
          echo "keyAlias=${{ secrets.KEY_ALIAS }}" >> android/key.properties
          echo "storeFile=keystore.jks" >> android/key.properties
          
          echo "Android keystore configured"
          echo "Key properties created:"
          cat android/key.properties
          
          # Verify the keystore file was created
          if [ -f "android/app/keystore.jks" ]; then
            echo "Keystore file created successfully at: android/app/keystore.jks"
            ls -la android/app/keystore.jks
          else
            echo "ERROR: Keystore file not found!"
            exit 1
          fi
        shell: bash

      - name: Configure Gradle memory
        if: ${{ matrix.target == 'Android' }}
        run: |
          # Create gradle.properties with increased heap size
          mkdir -p ~/.gradle
          echo "org.gradle.jvmargs=-Xmx4g -XX:MaxMetaspaceSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8" > ~/.gradle/gradle.properties

          # Also set it in the project if it exists
          if [ -f "android/gradle.properties" ]; then
            echo "" >> "android/gradle.properties"
            echo "org.gradle.jvmargs=-Xmx4g -XX:MaxMetaspaceSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8" >> "android/gradle.properties"
          fi
        shell: bash

      - name: Get Flutter Dependencies
        run: |
          flutter pub get

      - name: Setup CMake Arguments
        run: |
          CMAKE_ARGS="-DCMAKE_BUILD_TYPE=${{matrix.build-type}}"
          if ${{github.event_name == 'workflow_dispatch'}} && [ '${{ github.event.inputs.tag }}' ]; then
            CMAKE_ARGS="$CMAKE_ARGS -DGENIUS_DEPENDENCY_BRANCH=${{ github.event.inputs.tag }}"
            CMAKE_ARGS="$CMAKE_ARGS -DBRANCH_IS_TAG=ON"
          fi

          # Add verbose output for debugging
          CMAKE_ARGS="$CMAKE_ARGS -DCMAKE_VERBOSE_MAKEFILE=ON"

          # Windows-specific: ensure message output
          if [ "${{ matrix.target }}" = "Windows" ]; then
            CMAKE_ARGS="$CMAKE_ARGS -DCMAKE_MESSAGE_LOG_LEVEL=STATUS"
          fi

          EXTRA_ARGS=""
          if [ "${{ matrix.flutter-platform }}" = "ios" ]; then
            FLUTTER_BUILD_PLATFORM="ipa"
            # extra args needed only when building with flutter build ipa or macos - we're using proper code signing now
            EXTRA_ARGS="--export-options-plist=${{ matrix.flutter-platform }}/Runner/ExportOptions.plist"
          else
            FLUTTER_BUILD_PLATFORM="${{ matrix.flutter-platform }}"
          fi 

          echo "CMAKE_ARGUMENTS=$CMAKE_ARGS" >> $GITHUB_ENV
          echo "EXTRA_ARGS=$EXTRA_ARGS" >> $GITHUB_ENV
          echo "FLUTTER_BUILD_PLATFORM=$FLUTTER_BUILD_PLATFORM" >> $GITHUB_ENV
        shell: bash

      - name: Build Flutter
        shell: bash
        run: |
          if [ "${{ matrix.target }}" = "Windows" ]; then
            # Windows requires a different approach for CMAKE arguments
            set CMAKE_ARGUMENTS=$env:CMAKE_ARGUMENTS
            if [ "${{ matrix.build-type }}" = "Debug" ]; then
              flutter build windows --debug 
            else
              flutter build windows --release
            fi
          else
            # Other platforms respect CMAKE_ARGUMENTS environment variable
            if [ "${{ matrix.build-type }}" = "Debug" ]; then
              CMAKE_ARGUMENTS="${CMAKE_ARGUMENTS}" flutter build ${FLUTTER_BUILD_PLATFORM} --debug ${EXTRA_ARGS}
            else
              CMAKE_ARGUMENTS="${CMAKE_ARGUMENTS}" flutter build ${FLUTTER_BUILD_PLATFORM} --release ${EXTRA_ARGS} --verbose
            fi
          fi

      - name: Sign and package macOS app
        if: ${{ matrix.target == 'OSX' && (github.ref_name == 'main' || github.ref_name == 'develop') }}
        env:
          APPLE_ID: ${{ secrets.WALLET_NOTARIZE_APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          NOTARIZATION_PASSWORD: ${{ secrets.WALLET_NOTARIZATION_PASSWORD }}
        run: |
          cd build/macos/Build/Products/${{matrix.build-type}}
          
          # First, let's see what certificates are available
          echo "=== Available signing identities ==="
          security find-identity -v -p codesigning
          
          echo "=== All available identities (including installer) ==="
          security find-identity -v
          
          # Determine distribution type
          DISTRIBUTION_TYPE="${{ github.event.inputs.distribution_type }}"
          if [ -z "$DISTRIBUTION_TYPE" ]; then
            DISTRIBUTION_TYPE="both"
          fi
          
          # Function to sign app with specific identity
          sign_app() {
            local cert_name="$1"
            local app_name="$2"
            local output_dir="$3"
            
            echo "Signing app with identity: $cert_name"
            
            # Copy app to output directory
            mkdir -p "$output_dir"
            cp -R "Genius Wallet.app" "$output_dir/$app_name"
            
            # Check provisioning profile details
            echo "Checking for provisioning profile and entitlements..."
            if [ -f "$output_dir/$app_name/Contents/embedded.provisionprofile" ]; then
              echo "Found embedded provisioning profile"
              echo "Provisioning profile details:"
              security cms -D -i "$output_dir/$app_name/Contents/embedded.provisionprofile" | head -20
              
              # Extract entitlements from provisioning profile
              echo "Extracting entitlements from provisioning profile..."
              security cms -D -i "$output_dir/$app_name/Contents/embedded.provisionprofile" | plutil -extract Entitlements xml1 -o - - > "$output_dir/pp_entitlements.plist"
              
              if [ -f "$output_dir/pp_entitlements.plist" ]; then
                echo "Entitlements from provisioning profile:"
                cat "$output_dir/pp_entitlements.plist"
                entitlements_path="$output_dir/pp_entitlements.plist"
              else
                echo "Failed to extract entitlements from provisioning profile"
                entitlements_path=""
              fi
            else
              echo "No embedded provisioning profile found"
              entitlements_path=""
            fi
            
            # Sign with entitlements from provisioning profile if available
            if [ -n "$entitlements_path" ] && [ -f "$entitlements_path" ]; then
              echo "Signing with entitlements from provisioning profile..."
              codesign --force --deep --sign "$cert_name" --options runtime --timestamp --entitlements "$entitlements_path" "$output_dir/$app_name"
            else
              echo "No entitlements available, signing without..."
              codesign --force --deep --sign "$cert_name" --options runtime --timestamp "$output_dir/$app_name"
            fi
            
            # If that fails, try without runtime option
            if [ $? -ne 0 ]; then
              echo "Signing with runtime failed, trying without runtime option..."
              if [ -n "$entitlements_path" ] && [ -f "$entitlements_path" ]; then
                codesign --force --deep --sign "$cert_name" --timestamp --entitlements "$entitlements_path" "$output_dir/$app_name"
              else
                codesign --force --deep --sign "$cert_name" --timestamp "$output_dir/$app_name"
              fi
            fi
            
            # If that fails, try basic signing
            if [ $? -ne 0 ]; then
              echo "Timestamp signing failed, trying basic signing..."
              codesign --force --deep --sign "$cert_name" "$output_dir/$app_name"
            fi
            
            # Verify signature and show entitlements
            echo "Verifying signature..."
            codesign --verify --deep --strict "$output_dir/$app_name"
            if [ $? -eq 0 ]; then
              echo "Signature verification successful"
              echo "Signed app entitlements:"
              codesign -d --entitlements - "$output_dir/$app_name"
            else
              echo "Signature verification failed"
              return 1
            fi
            
            echo "App signed successfully: $output_dir/$app_name"
          }
          
          # Function to create and sign pkg
          create_pkg() {
            local app_path="$1"
            local pkg_name="$2"
            local installer_cert_name="$3"
            
            echo "Creating pkg: $pkg_name"
            echo "Using installer identity: $installer_cert_name"
            
            # Create unsigned pkg
            xcrun productbuild --component "$app_path" /Applications "${pkg_name}_unsigned.pkg"
            
            # Sign the pkg
            xcrun productsign --sign "$installer_cert_name" "${pkg_name}_unsigned.pkg" "$pkg_name"
            
            # Verify pkg signature
            pkgutil --check-signature "$pkg_name"
            
            echo "Package created and signed: $pkg_name"
          }
          
          # Function to notarize
          notarize() {
            local file_path="$1"
            
            echo "Notarizing: $file_path"
            
            # If it's an app bundle, we need to zip it first
            if [[ "$file_path" == *.app ]]; then
              local zip_path="${file_path}.zip"
              echo "Creating zip archive for notarization: $zip_path"
              
              # Create zip archive (ditto preserves resource forks and metadata)
              ditto -c -k --keepParent "$file_path" "$zip_path"
              
              # Submit the zip for notarization
              xcrun notarytool submit "$zip_path" \
                --apple-id "$APPLE_ID" \
                --team-id "$APPLE_TEAM_ID" \
                --password "$NOTARIZATION_PASSWORD" \
                --wait
              
              # Clean up the zip file
              rm "$zip_path"
              
              # Staple the notarization to the original app
              xcrun stapler staple "$file_path"
            else
              # For pkg files, submit directly
              xcrun notarytool submit "$file_path" \
                --apple-id "$APPLE_ID" \
                --team-id "$APPLE_TEAM_ID" \
                --password "$NOTARIZATION_PASSWORD" \
                --wait
              
              # Staple the notarization
              xcrun stapler staple "$file_path"
            fi
            
            echo "Notarization completed for: $file_path"
          }
          
          # Build App Store version
          if [ "$DISTRIBUTION_TYPE" = "both" ] || [ "$DISTRIBUTION_TYPE" = "testflight" ]; then
            echo "Building App Store version..."
            sign_app "Apple Distribution: Genius Ventures, Inc (WY) (P7T32QQX5V)" "Genius Wallet.app" "app_store"
            create_pkg "app_store/Genius Wallet.app" "Genius Wallet_AppStore.pkg" "3rd Party Mac Developer Installer: Genius Ventures, Inc (WY) (P7T32QQX5V)"
          fi
          
          # Build Developer ID version
          if [ "$DISTRIBUTION_TYPE" = "both" ] || [ "$DISTRIBUTION_TYPE" = "developer-id" ]; then
            echo "Building Developer ID version..."
            sign_app "Developer ID Application: Genius Ventures, Inc (WY) (P7T32QQX5V)" "Genius Wallet.app" "developer_id"
            
            # Notarize the app first
            notarize "developer_id/Genius Wallet.app"
            
            # Create and sign the pkg (keeping original naming)
            create_pkg "developer_id/Genius Wallet.app" "Genius Wallet.pkg" "Developer ID Installer: Genius Ventures, Inc (WY) (P7T32QQX5V)"
            
            # Notarize the pkg
            notarize "Genius Wallet.pkg"
          fi
          
          echo "macOS packaging completed"
          ls -la *.pkg
        shell: bash

      - name: Prepare artifacts
        if: github.ref_name == 'main' || github.ref_name == 'develop'
        run: |
          mkdir -p artifacts

          case "${{ matrix.target }}" in
            "Android")
              if [ "${{ matrix.build-type }}" = "Debug" ]; then
                cp build/app/outputs/flutter-apk/app-debug.apk artifacts/
              else
                cp build/app/outputs/flutter-apk/app-release.apk artifacts/
              fi
              ;;
            "iOS")
              # cp -r build/ios/iphoneos/*.ipa artifacts/ || true
              echo "Check testflight or appstore for current iOS Release" > artifacts/README.txt
              ;;
            "OSX")
              cd build/macos/Build/Products/${{matrix.build-type}}
              
              # Copy the signed packages
              cp -r *.pkg ../../../../../artifacts/ || true
              
              # Create a README explaining the different packages
              cat > ../../../../../artifacts/README.txt << EOF
          macOS Distribution Packages:

          - Genius Wallet_AppStore.pkg: For App Store/TestFlight distribution
          - Genius Wallet.pkg: For direct distribution outside App Store (notarized)

          Both packages are signed and ready for distribution.
          EOF
              ;;
            "Linux")
              cp -r build/linux/*/release/bundle artifacts/ || true
              cp -r build/linux/*/debug/bundle artifacts/ || true
              ;;
            "Windows")
              # Windows builds to build/windows/x64/runner/Release or Debug
              BUILD_DIR="build/windows/x64/runner/${{ matrix.build-type }}"
              
              echo "Looking for Windows build output in: $BUILD_DIR"
              
              if [ -d "$BUILD_DIR" ]; then
                echo "Found build directory: $BUILD_DIR"
                ls -la "$BUILD_DIR"
                # Copy the entire directory contents
                cp -r "$BUILD_DIR"/* artifacts/
                echo "Copied files to artifacts:"
                ls -la artifacts/
              else
                echo "Windows build directory not found at expected location: $BUILD_DIR"
                echo "Listing actual build structure:"
                find build/windows -type d 2>/dev/null || true
                echo "Windows build failed - build directory not found at $BUILD_DIR" > artifacts/build_error.txt
              fi
              ;;
          esac
        shell: bash

      - name: Compress build artifacts
        working-directory: ${{github.workspace}}
        if: github.ref_name == 'main' || github.ref_name == 'develop' || env.IS_TAG == 'true'
        run: |
          if [ '${{matrix.abi}}' ]; then
            BASE_NAME=${{matrix.target}}-${{matrix.abi}}-${{matrix.build-type}}
          else
            BASE_NAME=${{matrix.target}}-${{matrix.build-type}}
          fi
          
          # Android APKs don't need compression - upload directly
          if [ "${{ matrix.target }}" = "Android" ]; then
            if [ "${{ matrix.build-type }}" = "Debug" ]; then
              ARTIFACT_NAME=${BASE_NAME}.apk
              cp artifacts/app-debug.apk ${ARTIFACT_NAME}
            else
              ARTIFACT_NAME=${BASE_NAME}.apk
              cp artifacts/app-release.apk ${ARTIFACT_NAME}
            fi
          # macOS packages don't need compression - upload directly
          elif [ "${{ matrix.target }}" = "OSX" ]; then
            # For macOS, we'll upload packages directly without compression
            echo "macOS packages will be uploaded individually without compression"
          # Use appropriate compression format for other platforms
          elif [ "${{ matrix.target }}" = "Windows" ]; then
            ARTIFACT_NAME=${BASE_NAME}.zip
            # Use PowerShell to create zip on Windows
            powershell -Command "Compress-Archive -Path 'artifacts/*' -DestinationPath '${ARTIFACT_NAME}' -Force"
          else
            ARTIFACT_NAME=${BASE_NAME}.tar.gz
            tar -czvf ${ARTIFACT_NAME} artifacts/
          fi
          
          echo "ARTIFACT_NAME=${ARTIFACT_NAME}" >> $GITHUB_ENV
          
          if [ "${{ matrix.target }}" != "OSX" ]; then
            echo "Created artifact: ${ARTIFACT_NAME}"
            ls -la ${ARTIFACT_NAME}
          fi
        shell: bash

      - name: Wait for primary release creation
        if: (github.ref_name == 'main' || github.ref_name == 'develop' || env.IS_TAG == 'true') && (matrix.target == 'Linux' && matrix.abi == 'aarch64')
        working-directory: ${{github.workspace}}
        run: |
          if [ "$IS_TAG" == "true" ]; then
              RELEASE_TAG="${{ github.event.inputs.tag }}"
          else
              RELEASE_TAG='${{matrix.target}}-${{github.ref_name}}-${{matrix.build-type}}'
          fi
          
          echo "RELEASE_TAG=${RELEASE_TAG}" >> $GITHUB_ENV
          echo "Waiting for primary job to create/update release: $RELEASE_TAG"
          
          # Wait up to 120 minutes for the release to be created/updated
          ATTEMPT=1
          MAX_ATTEMPTS=720
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
              if gh release view $RELEASE_TAG >/dev/null 2>&1; then
                  echo "Release found!"
                  # Check if it's at the correct commit
                  if gh release view $RELEASE_TAG | grep -q "${{ github.sha }}"; then
                      echo "Release is at correct commit"
                      break
                  fi
              fi
              echo "Waiting for release... (attempt $ATTEMPT/$MAX_ATTEMPTS)"
              sleep 10
              ATTEMPT=$((ATTEMPT + 1))
          done
        shell: bash

      - name: Create release of GeniusWallet
        working-directory: ${{github.workspace}}
        if: (github.ref_name == 'main' || github.ref_name == 'develop' || env.IS_TAG == 'true') && !(matrix.target == 'Linux' && matrix.abi == 'aarch64')
        shell: bash
        run: |
          if ${{github.event_name == 'workflow_dispatch'}} && [ '${{ github.event.inputs.tag }}' ]; then
              RELEASE_TAG="${{ github.event.inputs.tag }}"
              IS_TAG_RELEASE="true"
          else
              RELEASE_TAG='${{matrix.target}}-${{github.ref_name}}-${{matrix.build-type}}'
              IS_TAG_RELEASE="false"
          fi

          echo "RELEASE_TAG=${RELEASE_TAG}" >> $GITHUB_ENV

          echo "Checking if release $RELEASE_TAG exists..."
          set +e
          gh release view "$RELEASE_TAG"
          releaseFound=$?
          set -e

           if [[ $releaseFound -eq 0 && "$IS_TAG_RELEASE" == "false" ]]; then
              echo "Deleting existing branch-based release + tag..."
              gh release delete "$RELEASE_TAG" --yes
              git push origin ":refs/tags/$RELEASE_TAG" || true
          fi

          # Force-create tag locally and push it
          echo "Tagging commit ${{ github.sha }} as $RELEASE_TAG"
          git tag -f "$RELEASE_TAG" "${{ github.sha }}"
          git push --force origin "$RELEASE_TAG"

          if [ "$IS_TAG_RELEASE" = "true" ]; then
              RELEASE_TYPE="--latest"
          else
              RELEASE_TYPE="--draft"
          fi
          gh release create "$RELEASE_TAG" \
            --target "${{ github.sha }}" \
            -t "${{ matrix.target }} ${{ github.ref_name }} ${{ matrix.build-type }} build" \
            -n "Branch: ${{ github.ref_name }} | SHA: ${{ github.sha }}" \
            ${RELEASE_TYPE}
          
      - name: Upload file
        if: github.ref_name == 'main' || github.ref_name == 'develop' || env.IS_TAG == 'true'
        working-directory: ${{github.workspace}}
        run: |
          # Upload artifacts
          if [ "${{ matrix.target }}" = "OSX" ]; then
            # Upload macOS packages individually
            for pkg in artifacts/*.pkg; do
              if [ -f "$pkg" ]; then
                echo "Uploading $(basename "$pkg")"
                gh release upload --clobber ${RELEASE_TAG} "$pkg"
              fi
            done
            
            # Upload README
            if [ -f "artifacts/README.txt" ]; then
              gh release upload --clobber ${RELEASE_TAG} "artifacts/README.txt"
            fi
          else
            echo "Uploading ${ARTIFACT_NAME}"
            gh release upload --clobber ${RELEASE_TAG} "${ARTIFACT_NAME}"
          fi
        shell: bash